{"version":3,"file":"graphics.js","sources":["../src/const.js","../src/styles/FillStyle.js","../src/utils/buildPoly.js","../src/utils/buildCircle.js","../src/utils/buildRectangle.js","../src/utils/buildRoundedRectangle.js","../src/utils/buildLine.js","../src/utils/buildComplexPoly.js","../src/utils/bezierCurveTo.js","../src/utils/Star.js","../src/utils/ArcUtils.js","../src/utils/BezierUtils.js","../src/utils/QuadraticUtils.js","../src/utils/BatchPart.js","../src/utils/index.js","../src/GraphicsData.js","../src/GraphicsGeometry.js","../src/styles/LineStyle.js","../src/Graphics.js"],"sourcesContent":["/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments: 2048,\n    _segmentsCount(length, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.FillStyle}\n     */\n    clone()\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /**\n     * Reset\n     */\n    reset()\n    {\n        /**\n         * The hex color value used when coloring the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.color = 0xFFFFFF;\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.alpha = 1;\n\n        /**\n         * The texture to be used for the fill.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.texture = Texture.WHITE;\n\n        /**\n         * The transform aplpied to the texture.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.matrix = null;\n\n        /**\n         * If the current fill is visible.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.visible = false;\n    }\n\n    /**\n     * Destroy and don't use after this\n     */\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = graphicsData.shape.points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","import { SHAPES } from '@pixi/math';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n\n        points.length = 0;\n\n        // TODO - bit hacky??\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            width = circleData.width;\n            height = circleData.height;\n        }\n\n        if (width === 0 || height === 0)\n        {\n            return;\n        }\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n\n        totalSegs /= 2.3;\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n\n        points.push(points[0], points[1]);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        const circle = graphicsData.shape;\n        const matrix = graphicsData.matrix;\n        const x = circle.x;\n        const y = circle.y;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n    },\n};\n","/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle = {\n\n    build(graphicsData)\n    {\n        const rrectData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        // Don't allow negative radius or greater than half the smallest width\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n\n        points.length = 0;\n\n        // No radius, do a simple rectangle\n        if (!radius)\n        {\n            points.push(x, y,\n                x + width, y,\n                x + width, y + height,\n                x, y + height);\n        }\n        else\n        {\n            quadraticBezierCurve(x, y + radius,\n                x, y,\n                x + radius, y,\n                points);\n            quadraticBezierCurve(x + width - radius,\n                y, x + width, y,\n                x + width, y + radius,\n                points);\n            quadraticBezierCurve(x + width, y + height - radius,\n                x + width, y + height,\n                x + width - radius, y + height,\n                points);\n            quadraticBezierCurve(x + radius, y + height,\n                x, y + height,\n                x, y + height - radius,\n                points);\n        }\n\n        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n        // TODO - fix this properly, this is not very elegant.. but it works for now.\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc)\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n","import { Point, SHAPES } from '@pixi/math';\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData, graphicsGeometry)\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData, graphicsGeometry)\n{\n    const shape = graphicsData.shape;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);\n        const midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    let indexStart = verts.length / 2;\n\n    // DRAW the Line\n    const width = style.width / 2;\n\n    // sort color\n    let p1x = points[0];\n    let p1y = points[1];\n    let p2x = points[2];\n    let p2y = points[3];\n    let p3x = 0;\n    let p3y = 0;\n\n    let perpx = -(p1y - p2y);\n    let perpy = p1x - p2x;\n    let perp2x = 0;\n    let perp2y = 0;\n    let perp3x = 0;\n    let perp3y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const r1 = (1 - ratio) * 2;\n    const r2 = ratio * 2;\n\n    // start\n    verts.push(\n        p1x - (perpx * r1),\n        p1y - (perpy * r1));\n\n    verts.push(\n        p1x + (perpx * r2),\n        p1y + (perpy * r2));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        p1x = points[(i - 1) * 2];\n        p1y = points[((i - 1) * 2) + 1];\n\n        p2x = points[i * 2];\n        p2y = points[(i * 2) + 1];\n\n        p3x = points[(i + 1) * 2];\n        p3y = points[((i + 1) * 2) + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        const a1 = (-perpy + p1y) - (-perpy + p2y);\n        const b1 = (-perpx + p2x) - (-perpx + p1x);\n        const c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));\n        const a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        const b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        const c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));\n\n        let denom = (a1 * b2) - (a2 * b1);\n\n        if (Math.abs(denom) < 0.1)\n        {\n            denom += 10.1;\n            verts.push(\n                p2x - (perpx * r1),\n                p2y - (perpy * r1));\n\n            verts.push(\n                p2x + (perpx * r2),\n                p2y + (perpy * r2));\n\n            continue;\n        }\n\n        const px = ((b1 * c2) - (b2 * c1)) / denom;\n        const py = ((a2 * c1) - (a1 * c2)) / denom;\n        const pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));\n\n        if (pdist > (196 * width * width))\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));\n\n            verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));\n\n            verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));\n\n            indexCount++;\n        }\n        else\n        {\n            verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));\n\n            verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));\n        }\n    }\n\n    p1x = points[(length - 2) * 2];\n    p1y = points[((length - 2) * 2) + 1];\n\n    p2x = points[(length - 1) * 2];\n    p2y = points[((length - 1) * 2) + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - (perpx * r1), p2y - (perpy * r1));\n\n    verts.push(p2x + (perpx * r2), p2y + (perpy * r2));\n\n    const indices = graphicsGeometry.indices;\n\n    // indices.push(indexStart);\n\n    for (let i = 0; i < indexCount - 2; ++i)\n    {\n        indices.push(indexStart, indexStart + 1, indexStart + 2);\n\n        indexStart++;\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry)\n{\n    let i = 0;\n\n    const shape = graphicsData.shape;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n","import { hex2rgb } from '@pixi/utils';\n\n/**\n * Builds a complex polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.Graphics} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n */\nexport function buildComplexPoly(graphicsData, webGLData)\n{\n    // TODO - no need to copy this as it gets turned into a Float32Array anyways..\n    const points = graphicsData.points.slice();\n\n    if (points.length < 6)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n    const indices = webGLData.indices;\n\n    webGLData.points = points;\n    webGLData.alpha = graphicsData.fillAlpha;\n    webGLData.color = hex2rgb(graphicsData.fillColor);\n\n    // calculate the bounds..\n    let minX = Infinity;\n    let maxX = -Infinity;\n\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    let x = 0;\n    let y = 0;\n\n    // get size..\n    for (let i = 0; i < points.length; i += 2)\n    {\n        x = points[i];\n        y = points[i + 1];\n\n        minX = x < minX ? x : minX;\n        maxX = x > maxX ? x : maxX;\n\n        minY = y < minY ? y : minY;\n        maxY = y > maxY ? y : maxY;\n    }\n\n    // add a quad to the end cos there is no point making another buffer!\n    points.push(minX, minY,\n        maxX, minY,\n        maxX, maxY,\n        minX, maxY);\n\n    // push a quad onto the end..\n\n    // TODO - this ain't needed!\n    const length = points.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        indices.push(i);\n    }\n}\n","/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @param {number} fromX - Starting point x\n * @param {number} fromY - Starting point y\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} cpX2 - Second Control point x\n * @param {number} cpY2 - Second Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number} n - Number of segments approximating the bezier curve\n * @param {number[]} [path=[]] - Path array to push points into\n * @return {number[]} Array of points of the curve\n */\nexport function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, path = [])\n{\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n\n    path.push(fromX, fromY);\n\n    for (let i = 1, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        path.push(\n            (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n            (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n        );\n    }\n\n    return path;\n}\n","import { Polygon, PI_2 } from '@pixi/math';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport class Star extends Polygon\n{\n    constructor(x, y, points, radius, innerRadius, rotation)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1, y1, x2, y2, radius, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param {number} startX - Start x location of arc\n     * @param {number} startY - Start y location of arc\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param {number} n - Number of segments\n     * @param {number[]} points - Collection of points to add to\n     */\n    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points)\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Path array to push points into\n     */\n    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, toX, toY)\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Points to add segments to.\n     */\n    static curveTo(cpX, cpY, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} style\n     * @param {number} startIndex\n     * @param {number} attribStart\n     */\n    begin(style, startIndex, attribStart)\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part\n     *\n     * @param {number} endIndex\n     * @param {number} endAttrib\n     */\n    end(endIndex, endAttrib)\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    reset()\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n","/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace PIXI.graphicsUtils\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './buildComplexPoly';\nexport * from './bezierCurveTo';\nexport * from './Star';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\nimport { SHAPES } from '@pixi/math';\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object}\n */\nexport const FILL_COMMANDS = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.graphicsUtils.BatchPart>}\n */\nexport const BATCH_POOL = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @type {Array<PIXI.BatchDrawCall>}\n */\nexport const DRAW_CALL_POOL = [];\n","/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     *\n     * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n     * @param {PIXI.Matrix} [matrix] - Transform matrix\n     */\n    constructor(shape, fillStyle = null, lineStyle = null, matrix = null)\n    {\n        /**\n         * The shape object to draw.\n         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n         */\n        this.shape = shape;\n\n        /**\n         * The style of the line.\n         * @member {PIXI.LineStyle}\n         */\n        this.lineStyle = lineStyle;\n\n        /**\n         * The style of the fill.\n         * @member {PIXI.FillStyle}\n         */\n        this.fillStyle = fillStyle;\n\n        /**\n         * The transform matrix.\n         * @member {PIXI.Matrix}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The type of the shape, see the Const.Shapes file for all the existing types,\n         * @member {number}\n         */\n        this.type = shape.type;\n\n        /**\n         * The collection of points.\n         * @member {number[]}\n         */\n        this.points = [];\n\n        /**\n         * The collection of holes.\n         * @member {PIXI.GraphicsData[]}\n         */\n        this.holes = [];\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return {PIXI.GraphicsData} Cloned GraphicsData object\n     */\n    clone()\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /**\n     * Destroys the Graphics data.\n     */\n    destroy()\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL } from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture } from '@pixi/core';\n\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    constructor()\n    {\n        super();\n\n        /**\n         * An array of points to draw, 2 numbers per point\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.points = [];\n\n        /**\n         * The collection of colors\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.colors = [];\n\n        /**\n         * The UVs collection\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.uvs = [];\n\n        /**\n         * The indices of the vertices\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.indices = [];\n\n        /**\n         * Reference to the texture IDs.\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.textureIds = [];\n\n        /**\n         * The collection of drawn shapes.\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @protected\n         */\n        this.graphicsData = [];\n\n        /**\n         * Used to detect if the graphics object has changed.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.dirty = 0;\n\n        /**\n         * Batches need to regenerated if the geometry is updated.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.batchDirty = -1;\n\n        /**\n         * Used to check if the cache is dirty.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.cacheDirty = -1;\n\n        /**\n         * Used to detect if we cleared the graphicsData.\n         *\n         * @member {number}\n         * @default 0\n         * @protected\n         */\n        this.clearDirty = 0;\n\n        /**\n         * List of current draw calls drived from the batches.\n         *\n         * @member {object[]}\n         * @protected\n         */\n        this.drawCalls = [];\n\n        /**\n         * Intermediate abstract format sent to batch system.\n         * Can be converted to drawCalls or to batchable objects.\n         *\n         * @member {PIXI.graphicsUtils.BatchPart[]}\n         * @protected\n         */\n        this.batches = [];\n\n        /**\n         * Index of the last batched shape in the stack of calls.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.shapeIndex = 0;\n\n        /**\n         * Cached bounds.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._bounds = new Bounds();\n\n        /**\n         * The bounds dirty flag.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Padding to add to the bounds.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.uvsFloat32 = null;\n\n        /**\n         * Minimal distance between points that are considered different.\n         * Affects line tesselation.\n         *\n         * @member {number}\n         */\n        this.closePointEps = 1e-4;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    get bounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    invalidate()\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawShape(shape, fillStyle, lineStyle, matrix)\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawHole(shape, matrix)\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.Point} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    containsPoint(point)\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches()\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        if (batchPart)\n        {\n            const index = this.indices.length;\n            const attrib = this.points.length / 2;\n\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        this.indicesUint16 = new Uint16Array(this.indices);\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    _compareStyles(styleA, styleB)\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!styleA.native !== !!styleB.native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    validateBatching()\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    packBatches()\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     *\n     * @protected\n     */\n    isBatchable()\n    {\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if (batches[i].style.native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    buildDrawCalls()\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.textures = new BatchTextureArray();\n        }\n        currentGroup.textures.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            const style = data.style;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.textures = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.textures.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    nextTexture.touched = 1;// touch;\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = 10497;\n\n                    currentGroup.textures.elements[currentGroup.textures.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize);\n            this.addTextureIds(textureIds, textureId, data.attribSize);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /**\n     * Packs attributes to single buffer.\n     *\n     * @protected\n     */\n    packAttributes()\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    processFill(data)\n    {\n        if (data.holes.length)\n        {\n            this.processHoles(data.holes);\n\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    processLine(data)\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     *\n     * @param {PIXI.GraphicsData[]} holes - Holes to render\n     * @protected\n     */\n    processHoles(holes)\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    calculateBounds()\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x + shape.width, shape.y + shape.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y,\n                    shape.radius + lineWidth, shape.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                sequenceBounds.addFramePad(shape.x, shape.y, shape.x, shape.y,\n                    shape.width + lineWidth, shape.height + lineWidth);\n            }\n            else\n            {\n                // adding directly to the bounds\n                bounds.addVerticesMatrix(curMatrix, shape.points, 0, shape.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    transformPoints(points, matrix)\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @protected\n     * @param {number[]} colors - List of colors to add to\n     * @param {number} color - Color to add\n     * @param {number} alpha - Alpha to use\n     * @param {number} size - Number of colors to add\n     */\n    addColors(colors, color, alpha, size)\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        while (size-- > 0)\n        {\n            colors.push(rgba);\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     *\n     * @protected\n     * @param {number[]} textureIds\n     * @param {number} id\n     * @param {number} size\n     */\n    addTextureIds(textureIds, id, size)\n    {\n        while (size-- > 0)\n        {\n            textureIds.push(id);\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @protected\n     * @param {number[]} verts - Vertices\n     * @param {number[]} uvs - UVs\n     * @param {PIXI.Texture} texture - Reference to Texture\n     * @param {number} start - Index buffer start index.\n     * @param {number} size - The size/length for index buffer.\n     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n     */\n    addUvs(verts, uvs, texture, start, size, matrix)\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     *\n     * @param {number[]} uvs array\n     * @param {PIXI.Texture} texture region\n     * @param {number} start starting index for uvs\n     * @param {number} size how many points to adjust\n     */\n    adjustUvs(uvs, texture, start, size)\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n\n/**\n * The maximum number of points to consider an object \"batchable\",\n * able to be batched by the renderer's batch system.\n *\n * @memberof PIXI.GraphicsGeometry\n * @static\n * @member {number} BATCHABLE_SIZE\n * @default 100\n */\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n","import { FillStyle } from './FillStyle';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nexport class LineStyle extends FillStyle\n{\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.LineStyle}\n     */\n    clone()\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n\n        return obj;\n    }\n    /**\n     * Reset the line style to default.\n     */\n    reset()\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.width = 0;\n\n        /**\n         * The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner).\n         *\n         * @member {number}\n         * @default 0.5\n         */\n        this.alignment = 0.5;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.native = false;\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport {\n    Texture,\n    Shader,\n    UniformGroup, State,\n} from '@pixi/core';\n\nimport {\n    BezierUtils,\n    QuadraticUtils,\n    ArcUtils,\n    Star,\n} from './utils';\n\nimport { hex2rgb, deprecation } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS = {};\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n     *        will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry = null)\n    {\n        super();\n        /**\n         * Includes vertex positions, face indices, normals, colors, UVs, and\n         * custom attributes within buffers, reducing the cost of passing all\n         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n         * @member {PIXI.GraphicsGeometry}\n         * @readonly\n         */\n        this.geometry = geometry || new GraphicsGeometry();\n\n        this.geometry.refCount++;\n\n        /**\n         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n         * Can be shared between multiple Graphics objects.\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n         * @member {PIXI.State}\n         */\n        this.state = State.for2d();\n\n        /**\n         * Current fill style\n         *\n         * @member {PIXI.FillStyle}\n         * @protected\n         */\n        this._fillStyle = new FillStyle();\n\n        /**\n         * Current line style\n         *\n         * @member {PIXI.LineStyle}\n         * @protected\n         */\n        this._lineStyle = new LineStyle();\n\n        /**\n         * Current shape transform matrix.\n         *\n         * @member {PIXI.Matrix}\n         * @protected\n         */\n        this._matrix = null;\n\n        /**\n         * Current hole mode is enabled.\n         *\n         * @member {boolean}\n         * @default false\n         * @protected\n         */\n        this._holeMode = false;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.Polygon}\n         * @protected\n         */\n        this.currentPath = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        /**\n         * A collections of batches! These can be drawn by the renderer batch system.\n         *\n         * @protected\n         * @member {object[]}\n         */\n        this.batches = [];\n\n        /**\n         * Update dirty for limiting calculating tints for batches.\n         *\n         * @protected\n         * @member {number}\n         * @default -1\n         */\n        this.batchTint = -1;\n\n        /**\n         * Copy of the object vertex data.\n         *\n         * @protected\n         * @member {Float32Array}\n         */\n        this.vertexData = null;\n\n        this._transformID = -1;\n        this.batchDirty = -1;\n\n        /**\n         * Renderer plugin for batching\n         *\n         * @member {string}\n         * @default 'batch'\n         */\n        this.pluginName = 'batch';\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        this.finishPoly();\n\n        return new Graphics(this.geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    set blendMode(value)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode()\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n    set tint(value)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    get fill()\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    get line()\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @method PIXI.Graphics#lineStyle\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {object} [options] - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(options)\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            const args = arguments;\n\n            options = {\n                width: args[0] || 0,\n                color: args[1] || 0x0,\n                alpha: args[2] !== undefined ? args[2] : 1,\n                alignment: args[3] !== undefined ? args[3] : 0.5,\n                native: !!args[4],\n            };\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param {object} [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTextureStyle(options)\n    {\n        // backward compatibility with params: (width, texture,\n        // color, alpha, matrix, alignment, native)\n        if (typeof options === 'number')\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#lineTextureStyle');\n\n            const [width, texture, color, alpha, matrix, alignment, native] = arguments;\n\n            options = { width, texture, color, alpha, matrix, alignment, native };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => options[key] === undefined && delete options[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally\n     * @protected\n     */\n    startPoly()\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly()\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     *\n     * @protected\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     */\n    _initCurve(x = 0, y = 0)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n     * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this.geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param {object} [options] - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options)\n    {\n        // backward compatibility with params: (texture, color, alpha, matrix)\n        if (options instanceof Texture)\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#beginTextureFill');\n\n            const [texture, color, alpha, matrix] = arguments;\n\n            options = { texture, color, alpha, matrix };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => options[key] === undefined && delete options[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closeStroke = true;// !!this._fillStyle;\n\n        // check if data has points..\n        if (points.points)\n        {\n            closeStroke = points.closeStroke;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawShape(shape)\n    {\n        if (!this._holeMode)\n        {\n            this.geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this.geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an arbitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawStar(x, y, points, radius, innerRadius, rotation = 0)\n    {\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        this.geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        return this.geometry.graphicsData.length === 1\n        && this.geometry.graphicsData[0].shape.type === SHAPES.RECT\n        && !this.geometry.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _render(renderer)\n    {\n        this.finishPoly();\n\n        const geometry = this.geometry;\n\n        // batch part..\n        // batch it!\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /**\n     * Populating batches for rendering\n     *\n     * @protected\n     */\n    _populateBatches()\n    {\n        const geometry = this.geometry;\n        const blendMode = this.blendMode;\n\n        this.batches = [];\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0, l = geometry.batches.length; i < l; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color),\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderBatched(renderer)\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderDirect(renderer)\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this.geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     *\n     * @param {PIXI.Renderer} renderer\n     * @param {PIXI.BatchDrawCall} drawCall\n     */\n    _renderDrawCallDirect(renderer, drawCall)\n    {\n        const { textures, type, size, start } = drawCall;\n        const groupTextureCount = textures.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(textures.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _resolveDirectShader(renderer)\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const sampleValues = new Int32Array(16);\n\n                for (let i = 0; i < 16; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @protected\n     */\n    _calculateBounds()\n    {\n        this.finishPoly();\n\n        const geometry = this.geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this.geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /**\n     * Recalcuate the tint by applying tin to batches using Graphics tint.\n     * @protected\n     */\n    calculateTints()\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recaculate the vertices.\n     * @protected\n     */\n    calculateVertices()\n    {\n        if (this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this.geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    setMatrix(matrix)\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    beginHole()\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    endHole()\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.geometry.refCount--;\n        if (this.geometry.refCount === 0)\n        {\n            this.geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this.geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Temporary point to use for containsPoint\n *\n * @static\n * @private\n * @member {PIXI.Point}\n */\nGraphics._TEMP_POINT = new Point();\n"],"names":["let","const","Texture","earcut","i","SHAPES","j","Point","hex2rgb","PI_2","super","Polygon","Bounds","WRAP_MODES","index","BaseTexture","BatchDrawCall","BatchTextureArray","DRAW_MODES","Matrix","premultiplyTint","BatchGeometry","State","BLEND_MODES","deprecation","radius","Rectangle","RoundedRectangle","Circle","Ellipse","arguments","UniformGroup","Shader","Container"],"mappings":"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"}