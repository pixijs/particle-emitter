{"version":3,"sources":["../../../AppData/Roaming/npm/node_modules/pixify/node_modules/browser-pack/_prelude.js","src/AnimatedParticle.js","src/Emitter.js","src/Particle.js","src/ParticleUtils.js","src/PathParticle.js","src/particles.js","src"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiParticles","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","ParticleUtils","Particle","Texture","PIXI","AnimatedParticle","emitter","textures","duration","framerate","elapsed","loop","prototype","p","Object","create","init","Particle_init","maxLife","applyArt","art","update","delta","Particle_update","frame","texture","EMPTY_TEXTURE","Particle_destroy","destroy","parseArt","data","j","tex","outTextures","output","push","fromImage","dupe","count","ParticleContainer","particles","ticker","shared","Emitter","particleParent","particleImages","config","_particleConstructor","startAlpha","endAlpha","startSpeed","endSpeed","minimumSpeedMultiplier","acceleration","maxSpeed","NaN","startScale","endScale","minimumScaleMultiplier","startColor","endColor","minLifetime","maxLifetime","minStartRotation","maxStartRotation","noRotation","minRotationSpeed","maxRotationSpeed","particleBlendMode","customEase","extraData","_frequency","maxParticles","emitterLifetime","spawnPos","spawnType","_spawnFunc","spawnRect","spawnCircle","particlesPerWave","particleSpacing","angleStart","rotation","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parentIsPC","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_origArt","_autoUpdate","_destroyWhenComplete","_completeCallback","parent","recycle","rotate","updateSpawnPos","updateOwnerPos","helperPoint","Point","defineProperty","get","set","value","cleanup","particle","next","removeChild","Array","isArray","slice","partClass","alpha","start","end","speed","x","y","scale","color","hexToRGB","startRotation","min","max","rotationSpeed","lifetime","getBlendMode","blendMode","ease","generateEase","parseData","_spawnRect","Rectangle","w","h","_spawnCircle","Circle","_spawnRing","minRadius","minR","_spawnBurst","_spawnPoint","frequency","pos","clone","emit","undefined","autoUpdate","prev","visible","newRot","diff","rotatePoint","resetPositionTracking","remove","add","playOnceAndDestroy","callback","playOnce","settings","TARGET_FPMS","prevX","prevY","curX","curY","Math","random","emitPosX","emitPosY","lerp","len","rand","particleConstructor","floor","children","shift","pop","index","indexOf","splice","unshift","addChildAt","addChild","position","width","height","radius","angle","Sprite","anchor","velocity","age","_sR","_sG","_sB","_eR","_eG","_eB","_doAlpha","_doScale","_doSpeed","_doAcceleration","_doColor","_doNormalMovement","_oneOverLife","kill","DEG_TO_RADS","tint","combineRGBComponents","normalize","scaleBy","currentSpeed","b","atan2","Sprite_Destroy","verbose","baseTexture","console","warn","BLEND_MODES","blendModes","PI","empty","EMPTY","on","once","sin","c","cos","xnew","ynew","point","oneOverLen","sqrt","charAt","substr","parseInt","segments","qty","oneOverQty","time","cp","name","NORMAL","toUpperCase","replace","PathParticle","path","initialRotation","initialPosition","movement","MATH_FUNCS","WHITELISTER","RegExp","parsePath","pathString","matches","match","join","Function","error","GLOBAL","prop"],"mappings":"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","file":"pixi-particles.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\r\n\r\nvar ParticleUtils = require(\"./ParticleUtils\"),\r\n\tParticle = require(\"./Particle\"),\r\n\tTexture = PIXI.Texture;\r\n\r\n/**\r\n * An individual particle image with an animation. Art data passed to the emitter must be\r\n * formatted in a particular way for AnimatedParticle to be able to handle it:\r\n *\r\n *     {\r\n *         //framerate is required. It is the animation speed of the particle in frames per\r\n *         //second.\r\n *         //A value of \"matchLife\" causes the animation to match the lifetime of an individual\r\n *         //particle, instead of at a constant framerate. This causes the animation to play\r\n *         //through one time, completing when the particle expires.\r\n *         framerate: 6,\r\n *         //loop is optional, and defaults to false.\r\n *         loop: true,\r\n *         //textures is required, and can be an array of any (non-zero) length.\r\n *         textures: [\r\n *             //each entry represents a single texture that should be used for one or more\r\n *             //frames. Any strings will be converted to Textures with Texture.fromImage().\r\n *             //Instances of PIXI.Texture will be used directly.\r\n *             \"animFrame1.png\",\r\n *             //entries can be an object with a 'count' property, telling AnimatedParticle to\r\n *             //use that texture for 'count' frames sequentially.\r\n *             {\r\n *                 texture: \"animFrame2.png\",\r\n *                 count: 3\r\n *             },\r\n *             \"animFrame3.png\"\r\n *         ]\r\n *     }\r\n *\r\n * @memberof PIXI.particles\r\n * @class AnimatedParticle\r\n * @extends PIXI.particles.Particle\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this AnimatedParticle.\r\n */\r\nvar AnimatedParticle = function(emitter)\r\n{\r\n\tParticle.call(this, emitter);\r\n\r\n\t/**\r\n\t * Texture array used as each frame of animation, similarly to how MovieClip works.\r\n\t * @property {Array} textures\r\n\t * @private\r\n\t */\r\n\tthis.textures = null;\r\n\r\n\t/**\r\n\t * Duration of the animation, in seconds.\r\n\t * @property {Number} duration\r\n\t * @private\r\n\t */\r\n\tthis.duration = 0;\r\n\r\n\t/**\r\n\t * Animation framerate, in frames per second.\r\n\t * @property {Number} framerate\r\n\t * @private\r\n\t */\r\n\tthis.framerate = 0;\r\n\r\n\t/**\r\n\t * Animation time elapsed, in seconds.\r\n\t * @property {Number} elapsed\r\n\t * @private\r\n\t */\r\n\tthis.elapsed = 0;\r\n\r\n\t/**\r\n\t * If this particle animation should loop.\r\n\t * @property {Boolean} loop\r\n\t * @private\r\n\t */\r\n\tthis.loop = false;\r\n};\r\n\r\n// Reference to the super class\r\nvar s = Particle.prototype;\r\n// Reference to the prototype\r\nvar p = AnimatedParticle.prototype = Object.create(s);\r\n\r\n/**\r\n * Initializes the particle for use, based on the properties that have to\r\n * have been set already on the particle.\r\n * @method PIXI.particles.AnimatedParticle#init\r\n */\r\np.init = function()\r\n{\r\n\tthis.Particle_init();\r\n\r\n\tthis.elapsed = 0;\r\n\r\n\t//if the animation needs to match the particle's life, then cacluate variables\r\n\tif(this.framerate < 0)\r\n\t{\r\n\t\tthis.duration = this.maxLife;\r\n\t\tthis.framerate = this.textures.length / this.duration;\r\n\t}\r\n};\r\n\r\n/**\r\n * Sets the textures for the particle.\r\n * @method PIXI.particles.AnimatedParticle#applyArt\r\n * @param {Array} art An array of PIXI.Texture objects for this animated particle.\r\n */\r\np.applyArt = function(art)\r\n{\r\n\tthis.textures = art.textures;\r\n\tthis.framerate = art.framerate;\r\n\tthis.duration = art.duration;\r\n\tthis.loop = art.loop;\r\n};\r\n\r\n/**\r\n * Updates the particle.\r\n * @method PIXI.particles.AnimatedParticle#update\r\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n */\r\np.update = function(delta)\r\n{\r\n\t//only animate the particle if it is still alive\r\n\tif(this.Particle_update(delta) >= 0)\r\n\t{\r\n\t\tthis.elapsed += delta;\r\n\t\tif(this.elapsed > this.duration)\r\n\t\t{\r\n\t\t\t//loop elapsed back around\r\n\t\t\tif(this.loop)\r\n\t\t\t\tthis.elapsed = this.elapsed % this.duration;\r\n\t\t\t//subtract a small amount to prevent attempting to go past the end of the animation\r\n\t\t\telse\r\n\t\t\t\tthis.elapsed = this.duration - 0.000001;\r\n\t\t}\r\n\t\tvar frame = (this.elapsed * this.framerate + 0.0000001) | 0;\r\n\t\tthis.texture = this.textures[frame] || ParticleUtils.EMPTY_TEXTURE;\r\n\t}\r\n};\r\n\r\np.Particle_destroy = Particle.prototype.destroy;\r\n/**\r\n * Destroys the particle, removing references and preventing future use.\r\n * @method PIXI.particles.AnimatedParticle#destroy\r\n */\r\np.destroy = function()\r\n{\r\n\tthis.Particle_destroy();\r\n\tthis.textures = null;\r\n};\r\n\r\n/**\r\n * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n * modifications to prepare it ahead of time.\r\n * @method PIXI.particles.AnimatedParticle.parseArt\r\n * @static\r\n * @param  {Array} art The array of art data, properly formatted for AnimatedParticle.\r\n * @return {Array} The art, after any needed modifications.\r\n */\r\nAnimatedParticle.parseArt = function(art)\r\n{\r\n\tvar i, data, output = [], j, textures, tex, outTextures;\r\n\tfor(i = 0; i < art.length; ++i)\r\n\t{\r\n\t\tdata = art[i];\r\n\t\tart[i] = output = {};\r\n\t\toutput.textures = outTextures = [];\r\n\t\ttextures = data.textures;\r\n\t\tfor(j = 0; j < textures.length; ++j)\r\n\t\t{\r\n\t\t\ttex = textures[j];\r\n\t\t\tif(typeof tex == \"string\")\r\n\t\t\t\toutTextures.push(Texture.fromImage(tex));\r\n\t\t\telse if(tex instanceof Texture)\r\n\t\t\t\toutTextures.push(tex);\r\n\t\t\t//assume an object with extra data determining duplicate frame data\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar dupe = tex.count || 1;\r\n\t\t\t\tif(typeof tex.texture == \"string\")\r\n\t\t\t\t\ttex = Texture.fromImage(tex.texture);\r\n\t\t\t\telse// if(tex.texture instanceof Texture)\r\n\t\t\t\t\ttex = tex.texture;\r\n\t\t\t\tfor(; dupe > 0; --dupe)\r\n\t\t\t\t{\r\n\t\t\t\t\toutTextures.push(tex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//use these values to signify that the animation should match the particle life time.\r\n\t\tif(data.framerate == \"matchLife\")\r\n\t\t{\r\n\t\t\t//-1 means that it should be calculated\r\n\t\t\toutput.framerate = -1;\r\n\t\t\toutput.duration = 0;\r\n\t\t\toutput.loop = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//determine if the animation should loop\r\n\t\t\toutput.loop = !!data.loop;\r\n\t\t\t//get the framerate, default to 60\r\n\t\t\toutput.framerate = data.framerate > 0 ? data.framerate : 60;\r\n\t\t\t//determine the duration\r\n\t\t\toutput.duration = outTextures.length / output.framerate;\r\n\t\t}\r\n\t}\r\n\r\n\treturn art;\r\n};\r\n\r\nmodule.exports = AnimatedParticle;","\"use strict\";\n\nvar ParticleUtils = require(\"./ParticleUtils\"),\n\tParticle = require(\"./Particle\"),\n\tParticleContainer = PIXI.particles.ParticleContainer || PIXI.ParticleContainer,\n\tticker = PIXI.ticker.shared;\n\n/**\n * A particle emitter.\n * @memberof PIXI.particles\n * @class Emitter\n * @constructor\n * @param {PIXI.Container} particleParent The container to add the\n *                                                     particles to.\n * @param {Array|PIXI.Texture|String} [particleImages] A texture or array of textures to use\n *                                                     for the particles. Strings will be turned\n *                                                     into textures via Texture.fromImage().\n * @param {Object} [config] A configuration object containing settings for the emitter.\n * @param {Boolean} [config.emit=true] If config.emit is explicitly passed as false, the Emitter\n *                                     will start disabled.\n * @param {Boolean} [config.autoUpdate=false] If config.emit is explicitly passed as true, the Emitter\n *                                     will automatically call update via the PIXI shared ticker.\n */\nvar Emitter = function(particleParent, particleImages, config)\n{\n\t/**\n\t * The constructor used to create new particles. The default is\n\t * the built in particle class.\n\t * @property {Function} _particleConstructor\n\t * @private\n\t */\n\tthis._particleConstructor = Particle;\n\t//properties for individual particles\n\t/**\n\t * An array of PIXI Texture objects.\n\t * @property {Array} particleImages\n\t */\n\tthis.particleImages = null;\n\t/**\n\t * The starting alpha of all particles.\n\t * @property {Number} startAlpha\n\t * @default 1\n\t */\n\tthis.startAlpha = 1;\n\t/**\n\t * The ending alpha of all particles.\n\t * @property {Number} endAlpha\n\t * @default 1\n\t */\n\tthis.endAlpha = 1;\n\t/**\n\t * The starting speed of all particles.\n\t * @property {Number} startSpeed\n\t * @default 0\n\t */\n\tthis.startSpeed = 0;\n\t/**\n\t * The ending speed of all particles.\n\t * @property {Number} endSpeed\n\t * @default 0\n\t */\n\tthis.endSpeed = 0;\n\t/**\n\t * A minimum multiplier for the speed of a particle at both start and\n\t * end. A value between minimumSpeedMultiplier and 1 is randomly generated\n\t * and multiplied with startSpeed and endSpeed to provide the actual\n\t * startSpeed and endSpeed for each particle.\n\t * @property {Number} minimumSpeedMultiplier\n\t * @default 1\n\t */\n\tthis.minimumSpeedMultiplier = 1;\n\t/**\n\t * Acceleration to apply to particles. Using this disables\n\t * any interpolation of particle speed. If the particles do\n\t * not have a rotation speed, then they will be rotated to\n\t * match the direction of travel.\n\t * @property {PIXI.Point} acceleration\n\t * @default null\n\t */\n\tthis.acceleration = null;\n\t/**\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n\t * will disable the maximum speed.\n\t * @property {Number} maxSpeed\n\t * @default NaN\n\t */\n\tthis.maxSpeed = NaN;\n\t/**\n\t * The starting scale of all particles.\n\t * @property {Number} startScale\n\t * @default 1\n\t */\n\tthis.startScale = 1;\n\t/**\n\t * The ending scale of all particles.\n\t * @property {Number} endScale\n\t * @default 1\n\t */\n\tthis.endScale = 1;\n\t/**\n\t * A minimum multiplier for the scale of a particle at both start and\n\t * end. A value between minimumScaleMultiplier and 1 is randomly generated\n\t * and multiplied with startScale and endScale to provide the actual\n\t * startScale and endScale for each particle.\n\t * @property {Number} minimumScaleMultiplier\n\t * @default 1\n\t */\n\tthis.minimumScaleMultiplier = 1;\n\t/**\n\t * The starting color of all particles, as red, green, and blue uints from 0-255.\n\t * @property {Array} startColor\n\t */\n\tthis.startColor = null;\n\t/**\n\t * The ending color of all particles, as red, green, and blue uints from 0-255.\n\t * @property {Array} endColor\n\t */\n\tthis.endColor = null;\n\t/**\n\t * The minimum lifetime for a particle, in seconds.\n\t * @property {Number} minLifetime\n\t */\n\tthis.minLifetime = 0;\n\t/**\n\t * The maximum lifetime for a particle, in seconds.\n\t * @property {Number} maxLifetime\n\t */\n\tthis.maxLifetime = 0;\n\t/**\n\t * The minimum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} minStartRotation\n\t */\n\tthis.minStartRotation = 0;\n\t/**\n\t * The maximum start rotation for a particle, in degrees. This value\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\n\t * @property {Number} maxStartRotation\n\t */\n\tthis.maxStartRotation = 0;\n\t/**\n\t * If no particle rotation should occur. Starting rotation will still\n\t * affect the direction in which particles move. If the rotation speed\n\t * is set, then this will be ignored.\n\t * @property {Boolean} maxStartRotation\n\t */\n\tthis.noRotation = false;\n\t/**\n\t * The minimum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} minRotationSpeed\n\t */\n\tthis.minRotationSpeed = 0;\n\t/**\n\t * The maximum rotation speed for a particle, in degrees per second.\n\t * This only visually spins the particle, it does not change direction\n\t * of movement.\n\t * @property {Number} maxRotationSpeed\n\t */\n\tthis.maxRotationSpeed = 0;\n\t/**\n\t * The blend mode for all particles, as named by PIXI.blendModes.\n\t * @property {int} particleBlendMode\n\t */\n\tthis.particleBlendMode = 0;\n\t/**\n\t * An easing function for nonlinear interpolation of values. Accepts a single\n\t * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n\t * from 0-1, inclusive.\n\t * @property {Function} customEase\n\t */\n\tthis.customEase = null;\n\t/**\n\t *\tExtra data for use in custom particles. The emitter doesn't look inside, but\n\t *\tpasses it on to the particle to use in init().\n\t *\t@property {Object} extraData\n\t */\n\tthis.extraData = null;\n\t//properties for spawning particles\n\t/**\n\t * Time between particle spawns in seconds.\n\t * @property {Number} _frequency\n\t * @private\n\t */\n\tthis._frequency = 1;\n\t/**\n\t * Maximum number of particles to keep alive at a time. If this limit\n\t * is reached, no more particles will spawn until some have died.\n\t * @property {int} maxParticles\n\t * @default 1000\n\t */\n\tthis.maxParticles = 1000;\n\t/**\n\t * The amount of time in seconds to emit for before setting emit to false.\n\t * A value of -1 is an unlimited amount of time.\n\t * @property {Number} emitterLifetime\n\t * @default -1\n\t */\n\tthis.emitterLifetime = -1;\n\t/**\n\t * Position at which to spawn particles, relative to the emitter's owner's origin.\n\t * For example, the flames of a rocket travelling right might have a spawnPos\n\t * of {x:-50, y:0}.\n\t * to spawn at the rear of the rocket.\n\t * To change this, use updateSpawnPos().\n\t * @property {PIXI.Point} spawnPos\n\t * @readOnly\n\t */\n\tthis.spawnPos = null;\n\t/**\n\t * How the particles will be spawned. Valid types are \"point\", \"rectangle\",\n\t * \"circle\", \"burst\", \"ring\".\n\t * @property {String} spawnType\n\t * @readOnly\n\t */\n\tthis.spawnType = null;\n\t/**\n\t * A reference to the emitter function specific to the spawn type.\n\t * @property {Function} _spawnFunc\n\t * @private\n\t */\n\tthis._spawnFunc = null;\n\t/**\n\t * A rectangle relative to spawnPos to spawn particles inside if the spawn type is \"rect\".\n\t * @property {PIXI.Rectangle} spawnRect\n\t */\n\tthis.spawnRect = null;\n\t/**\n\t * A circle relative to spawnPos to spawn particles inside if the spawn type is \"circle\".\n\t * @property {PIXI.Circle} spawnCircle\n\t */\n\tthis.spawnCircle = null;\n\t/**\n\t * Number of particles to spawn each wave in a burst.\n\t * @property {int} particlesPerWave\n\t * @default 1\n\t */\n\tthis.particlesPerWave = 1;\n\t/**\n\t * Spacing between particles in a burst. 0 gives a random angle for each particle.\n\t * @property {Number} particleSpacing\n\t * @default 0\n\t */\n\tthis.particleSpacing = 0;\n\t/**\n\t * Angle at which to start spawning particles in a burst.\n\t * @property {Number} angleStart\n\t * @default 0\n\t */\n\tthis.angleStart = 0;\n\t/**\n\t * Rotation of the emitter or emitter's owner in degrees. This is added to\n\t * the calculated spawn angle.\n\t * To change this, use rotate().\n\t * @property {Number} rotation\n\t * @default 0\n\t * @readOnly\n\t */\n\tthis.rotation = 0;\n\t/**\n\t * The world position of the emitter's owner, to add spawnPos to when\n\t * spawning particles. To change this, use updateOwnerPos().\n\t * @property {PIXI.Point} ownerPos\n\t * @default {x:0, y:0}\n\t * @readOnly\n\t */\n\tthis.ownerPos = null;\n\t/**\n\t * The origin + spawnPos in the previous update, so that the spawn position\n\t * can be interpolated to space out particles better.\n\t * @property {PIXI.Point} _prevEmitterPos\n\t * @private\n\t */\n\tthis._prevEmitterPos = null;\n\t/**\n\t * If _prevEmitterPos is valid, to prevent interpolation on the first update\n\t * @property {Boolean} _prevPosIsValid\n\t * @private\n\t * @default false\n\t */\n\tthis._prevPosIsValid = false;\n\t/**\n\t * If either ownerPos or spawnPos has changed since the previous update.\n\t * @property {Boolean} _posChanged\n\t * @private\n\t */\n\tthis._posChanged = false;\n\t/**\n\t * If the parent is a ParticleContainer from Pixi V3\n\t * @property {Boolean} _parentIsPC\n\t * @private\n\t */\n\tthis._parentIsPC = false;\n\t/**\n\t * The container to add particles to.\n\t * @property {PIXI.Container} _parent\n\t * @private\n\t */\n\tthis._parent = null;\n\t/**\n\t * If particles should be added at the back of the display list instead of the front.\n\t * @property {Boolean} addAtBack\n\t */\n\tthis.addAtBack = false;\n\t/**\n\t * The current number of active particles.\n\t * @property {Number} particleCount\n\t * @readOnly\n\t */\n\tthis.particleCount = 0;\n\t/**\n\t * If particles should be emitted during update() calls. Setting this to false\n\t * stops new particles from being created, but allows existing ones to die out.\n\t * @property {Boolean} _emit\n\t * @private\n\t */\n\tthis._emit = false;\n\t/**\n\t * The timer for when to spawn particles in seconds, where numbers less\n\t * than 0 mean that particles should be spawned.\n\t * @property {Number} _spawnTimer\n\t * @private\n\t */\n\tthis._spawnTimer = 0;\n\t/**\n\t * The life of the emitter in seconds.\n\t * @property {Number} _emitterLife\n\t * @private\n\t */\n\tthis._emitterLife = -1;\n\t/**\n\t * The particles that are active and on the display list. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesFirst\n\t * @private\n\t */\n\tthis._activeParticlesFirst = null;\n\t/**\n\t * The particles that are active and on the display list. This is the last particle in a\n\t * linked list.\n\t * @property {Particle} _activeParticlesLast\n\t * @private\n\t */\n\tthis._activeParticlesLast = null;\n\t/**\n\t * The particles that are not currently being used. This is the first particle in a\n\t * linked list.\n\t * @property {Particle} _poolFirst\n\t * @private\n\t */\n\tthis._poolFirst = null;\n\t/**\n\t * The original config object that this emitter was initialized with.\n\t * @property {Object} _origConfig\n\t * @private\n\t */\n\tthis._origConfig = null;\n\t/**\n\t * The original particle image data that this emitter was initialized with.\n\t * @property {PIXI.Texture|Array|String} _origArt\n\t * @private\n\t */\n\tthis._origArt = null;\n\t/**\n\t * If the update function is called automatically from the shared ticker.\n\t * Setting this to false requires calling the update function manually.\n\t * @property {Boolean} _autoUpdate\n\t * @private\n\t */\n\tthis._autoUpdate = false;\n\t/**\n\t * If the emitter should destroy itself when all particles have died out. This is set by\n\t * playOnceAndDestroy();\n\t * @property {Boolean} _destroyWhenComplete\n\t * @private\n\t */\n\tthis._destroyWhenComplete = false;\n\t/**\n\t * A callback for when all particles have died out. This is set by\n\t * playOnceAndDestroy() or playOnce();\n\t * @property {Function} _completeCallback\n\t * @private\n\t */\n\tthis._completeCallback = null;\n\n\t//set the initial parent\n\tthis.parent = particleParent;\n\n\tif(particleImages && config)\n\t\tthis.init(particleImages, config);\n\n\t//save often used functions on the instance instead of the prototype for better speed\n\tthis.recycle = this.recycle;\n\tthis.update = this.update;\n\tthis.rotate = this.rotate;\n\tthis.updateSpawnPos = this.updateSpawnPos;\n\tthis.updateOwnerPos = this.updateOwnerPos;\n};\n\n// Reference to the prototype\nvar p = Emitter.prototype = {};\n\nvar helperPoint = new PIXI.Point();\n\n/**\n * Time between particle spawns in seconds. If this value is not a number greater than 0,\n * it will be set to 1 (particle per second) to prevent infinite loops.\n * @member {Number} PIXI.particles.Emitter#frequency\n */\nObject.defineProperty(p, \"frequency\",\n{\n\tget: function() { return this._frequency; },\n\tset: function(value)\n\t{\n\t\t//do some error checking to prevent infinite loops\n\t\tif(typeof value == \"number\" && value > 0)\n\t\t\tthis._frequency = value;\n\t\telse\n\t\t\tthis._frequency = 1;\n\t}\n});\n\n/**\n * The constructor used to create new particles. The default is\n * the built in Particle class. Setting this will dump any active or\n * pooled particles, if the emitter has already been used.\n * @member {Function} PIXI.particles.Emitter#particleConstructor\n */\nObject.defineProperty(p, \"particleConstructor\",\n{\n\tget: function() { return this._particleConstructor; },\n\tset: function(value)\n\t{\n\t\tif(value != this._particleConstructor)\n\t\t{\n\t\t\tthis._particleConstructor = value;\n\t\t\t//clean up existing particles\n\t\t\tthis.cleanup();\n\t\t\t//scrap all the particles\n\t\t\tfor (var particle = this._poolFirst; particle; particle = particle.next)\n\t\t\t{\n\t\t\t\tparticle.destroy();\n\t\t\t}\n\t\t\tthis._poolFirst = null;\n\t\t\t//re-initialize the emitter so that the new constructor can do anything it needs to\n\t\t\tif(this._origConfig && this._origArt)\n\t\t\t\tthis.init(this._origArt, this._origConfig);\n\t\t}\n\t}\n});\n\n/**\n* The container to add particles to. Settings this will dump any active particles.\n* @member {PIXI.Container} PIXI.particles.Emitter#parent\n*/\nObject.defineProperty(p, \"parent\",\n{\n\tget: function() { return this._parent; },\n\tset: function(value)\n\t{\n\t\t//if our previous parent was a ParticleContainer, then we need to remove\n\t\t//pooled particles from it\n\t\tif (this._parentIsPC) {\n\t\t\tfor (var particle = this._poolFirst; particle; particle = particle.next)\n\t\t\t{\n\t\t\t\tif(particle.parent)\n\t\t\t\t\tparticle.parent.removeChild(particle);\n\t\t\t}\n\t\t}\n\t\tthis.cleanup();\n\t\tthis._parent = value;\n\t\tthis._parentIsPC = ParticleContainer && value && value instanceof ParticleContainer;\n\t}\n});\n\n/**\n * Sets up the emitter based on the config settings.\n * @method PIXI.particles.Emitter#init\n * @param {Array|PIXI.Texture} art A texture or array of textures to use for the particles.\n * @param {Object} config A configuration object containing settings for the emitter.\n */\np.init = function(art, config)\n{\n\tif(!art || !config)\n\t\treturn;\n\t//clean up any existing particles\n\tthis.cleanup();\n\n\t//store the original config and particle images, in case we need to re-initialize\n\t//when the particle constructor is changed\n\tthis._origConfig = config;\n\tthis._origArt = art;\n\n\t//set up the array of data, also ensuring that it is an array\n\tart = Array.isArray(art) ? art.slice() : [art];\n\t//run the art through the particle class's parsing function\n\tvar partClass = this._particleConstructor;\n\tthis.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\n\t///////////////////////////\n\t// Particle Properties   //\n\t///////////////////////////\n\t//set up the alpha\n\tif (config.alpha)\n\t{\n\t\tthis.startAlpha = config.alpha.start;\n\t\tthis.endAlpha = config.alpha.end;\n\t}\n\telse\n\t\tthis.startAlpha = this.endAlpha = 1;\n\t//set up the speed\n\tif (config.speed)\n\t{\n\t\tthis.startSpeed = config.speed.start;\n\t\tthis.endSpeed = config.speed.end;\n\t\tthis.minimumSpeedMultiplier = config.speed.minimumSpeedMultiplier || 1;\n\t}\n\telse\n\t{\n\t\tthis.minimumSpeedMultiplier = 1;\n\t\tthis.startSpeed = this.endSpeed = 0;\n\t}\n\t//set up acceleration\n\tvar acceleration = config.acceleration;\n\tif(acceleration && (acceleration.x || acceleration.y))\n\t{\n\t\tthis.endSpeed = this.startSpeed;\n\t\tthis.acceleration = new PIXI.Point(acceleration.x, acceleration.y);\n\t\tthis.maxSpeed = config.maxSpeed || NaN;\n\t}\n\telse\n\t\tthis.acceleration = new PIXI.Point();\n\t//set up the scale\n\tif (config.scale)\n\t{\n\t\tthis.startScale = config.scale.start;\n\t\tthis.endScale = config.scale.end;\n\t\tthis.minimumScaleMultiplier = config.scale.minimumScaleMultiplier || 1;\n\t}\n\telse\n\t\tthis.startScale = this.endScale = this.minimumScaleMultiplier = 1;\n\t//set up the color\n\tif (config.color)\n\t{\n\t\tthis.startColor = ParticleUtils.hexToRGB(config.color.start);\n\t\t//if it's just one color, only use the start color\n\t\tif (config.color.start != config.color.end)\n\t\t{\n\t\t\tthis.endColor = ParticleUtils.hexToRGB(config.color.end);\n\t\t}\n\t\telse\n\t\t\tthis.endColor = null;\n\t}\n\t//set up the start rotation\n\tif (config.startRotation)\n\t{\n\t\tthis.minStartRotation = config.startRotation.min;\n\t\tthis.maxStartRotation = config.startRotation.max;\n\t}\n\telse\n\t\tthis.minStartRotation = this.maxStartRotation = 0;\n\tif (config.noRotation &&\n\t\t(this.minStartRotation || this.maxStartRotation))\n\t{\n\t\tthis.noRotation = !!config.noRotation;\n\t}\n\telse\n\t\tthis.noRotation = false;\n\t//set up the rotation speed\n\tif (config.rotationSpeed)\n\t{\n\t\tthis.minRotationSpeed = config.rotationSpeed.min;\n\t\tthis.maxRotationSpeed = config.rotationSpeed.max;\n\t}\n\telse\n\t\tthis.minRotationSpeed = this.maxRotationSpeed = 0;\n\t//set up the lifetime\n\tthis.minLifetime = config.lifetime.min;\n\tthis.maxLifetime = config.lifetime.max;\n\t//get the blend mode\n\tthis.particleBlendMode = ParticleUtils.getBlendMode(config.blendMode);\n\t//use the custom ease if provided\n\tif (config.ease)\n\t{\n\t\tthis.customEase = typeof config.ease == \"function\" ?\n\t\t\t\t\t\t\t\t\t\t\t\t\tconfig.ease :\n\t\t\t\t\t\t\t\t\t\t\t\t\tParticleUtils.generateEase(config.ease);\n\t}\n\telse\n\t\tthis.customEase = null;\n\t//set up the extra data, running it through the particle class's parseData function.\n\tif(partClass.parseData)\n\t\tthis.extraData = partClass.parseData(config.extraData);\n\telse\n\t\tthis.extraData = config.extraData || null;\n\t//////////////////////////\n\t// Emitter Properties   //\n\t//////////////////////////\n\t//reset spawn type specific settings\n\tthis.spawnRect = this.spawnCircle = null;\n\tthis.particlesPerWave = 1;\n\tthis.particleSpacing = 0;\n\tthis.angleStart = 0;\n\tvar spawnCircle;\n\t//determine the spawn function to use\n\tswitch(config.spawnType)\n\t{\n\t\tcase \"rect\":\n\t\t\tthis.spawnType = \"rect\";\n\t\t\tthis._spawnFunc = this._spawnRect;\n\t\t\tvar spawnRect = config.spawnRect;\n\t\t\tthis.spawnRect = new PIXI.Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\n\t\t\tbreak;\n\t\tcase \"circle\":\n\t\t\tthis.spawnType = \"circle\";\n\t\t\tthis._spawnFunc = this._spawnCircle;\n\t\t\tspawnCircle = config.spawnCircle;\n\t\t\tthis.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n\t\t\tbreak;\n\t\tcase \"ring\":\n\t\t\tthis.spawnType = \"ring\";\n\t\t\tthis._spawnFunc = this._spawnRing;\n\t\t\tspawnCircle = config.spawnCircle;\n\t\t\tthis.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n\t\t\tthis.spawnCircle.minRadius = spawnCircle.minR;\n\t\t\tbreak;\n\t\tcase \"burst\":\n\t\t\tthis.spawnType = \"burst\";\n\t\t\tthis._spawnFunc = this._spawnBurst;\n\t\t\tthis.particlesPerWave = config.particlesPerWave;\n\t\t\tthis.particleSpacing = config.particleSpacing;\n\t\t\tthis.angleStart = config.angleStart ? config.angleStart : 0;\n\t\t\tbreak;\n\t\tcase \"point\":\n\t\t\tthis.spawnType = \"point\";\n\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.spawnType = \"point\";\n\t\t\tthis._spawnFunc = this._spawnPoint;\n\t\t\tbreak;\n\t}\n\t//set the spawning frequency\n\tthis.frequency = config.frequency;\n\t//set the emitter lifetime\n\tthis.emitterLifetime = config.emitterLifetime || -1;\n\t//set the max particles\n\tthis.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n\t//determine if we should add the particle at the back of the list or not\n\tthis.addAtBack = !!config.addAtBack;\n\t//reset the emitter position and rotation variables\n\tthis.rotation = 0;\n\tthis.ownerPos = new PIXI.Point();\n\tthis.spawnPos = new PIXI.Point(config.pos.x, config.pos.y);\n\tthis._prevEmitterPos = this.spawnPos.clone();\n\t//previous emitter position is invalid and should not be used for interpolation\n\tthis._prevPosIsValid = false;\n\t//start emitting\n\tthis._spawnTimer = 0;\n\tthis.emit = config.emit === undefined ? true : !!config.emit;\n\tthis.autoUpdate = config.autoUpdate === undefined ? false : !!config.autoUpdate;\n};\n\n/**\n * Recycles an individual particle.\n * @method PIXI.particles.Emitter#recycle\n * @param {Particle} particle The particle to recycle.\n * @private\n */\np.recycle = function(particle)\n{\n\tif(particle.next)\n\t\tparticle.next.prev = particle.prev;\n\tif(particle.prev)\n\t\tparticle.prev.next = particle.next;\n\tif(particle == this._activeParticlesLast)\n\t\tthis._activeParticlesLast = particle.prev;\n\tif(particle == this._activeParticlesFirst)\n\t\tthis._activeParticlesFirst = particle.next;\n\t//add to pool\n\tparticle.prev = null;\n\tparticle.next = this._poolFirst;\n\tthis._poolFirst = particle;\n\t//remove child from display, or make it invisible if it is in a ParticleContainer\n\tif(this._parentIsPC)\n\t{\n\t\tparticle.alpha = 0;\n\t\tparticle.visible = false;\n\t}\n\telse\n\t{\n\t\tif(particle.parent)\n\t\t\tparticle.parent.removeChild(particle);\n\t}\n\t//decrease count\n\t--this.particleCount;\n};\n\n/**\n * Sets the rotation of the emitter to a new value.\n * @method PIXI.particles.Emitter#rotate\n * @param {Number} newRot The new rotation, in degrees.\n */\np.rotate = function(newRot)\n{\n\tif (this.rotation == newRot) return;\n\t//caclulate the difference in rotation for rotating spawnPos\n\tvar diff = newRot - this.rotation;\n\tthis.rotation = newRot;\n\t//rotate spawnPos\n\tParticleUtils.rotatePoint(diff, this.spawnPos);\n\t//mark the position as having changed\n\tthis._posChanged = true;\n};\n\n/**\n * Changes the spawn position of the emitter.\n * @method PIXI.particles.Emitter#updateSpawnPos\n * @param {Number} x The new x value of the spawn position for the emitter.\n * @param {Number} y The new y value of the spawn position for the emitter.\n */\np.updateSpawnPos = function(x, y)\n{\n\tthis._posChanged = true;\n\tthis.spawnPos.x = x;\n\tthis.spawnPos.y = y;\n};\n\n/**\n * Changes the position of the emitter's owner. You should call this if you are adding\n * particles to the world container that your emitter's owner is moving around in.\n * @method PIXI.particles.Emitter#updateOwnerPos\n * @param {Number} x The new x value of the emitter's owner.\n * @param {Number} y The new y value of the emitter's owner.\n */\np.updateOwnerPos = function(x, y)\n{\n\tthis._posChanged = true;\n\tthis.ownerPos.x = x;\n\tthis.ownerPos.y = y;\n};\n\n/**\n * Prevents emitter position interpolation in the next update.\n * This should be used if you made a major position change of your emitter's owner\n * that was not normal movement.\n * @method PIXI.particles.Emitter#resetPositionTracking\n */\np.resetPositionTracking = function()\n{\n\tthis._prevPosIsValid = false;\n};\n\n/**\n * If particles should be emitted during update() calls. Setting this to false\n * stops new particles from being created, but allows existing ones to die out.\n * @member {Boolean} PIXI.particles.Emitter#emit\n */\nObject.defineProperty(p, \"emit\",\n{\n\tget: function() { return this._emit; },\n\tset: function(value)\n\t{\n\t\tthis._emit = !!value;\n\t\tthis._emitterLife = this.emitterLifetime;\n\t}\n});\n\n/**\n * If the update function is called automatically from the shared ticker.\n * Setting this to false requires calling the update function manually.\n * @member {Boolean} PIXI.particles.Emitter#autoUpdate\n */\nObject.defineProperty(p, \"autoUpdate\",\n{\n\tget: function() { return this._autoUpdate; },\n\tset: function(value)\n\t{\n\t\tif (this._autoUpdate && !value)\n\t\t{\n\t\t\tticker.remove(this.update, this);\n\t\t}\n\t\telse if (!this._autoUpdate && value)\n\t\t{\n\t\t\tticker.add(this.update, this);\n\t\t}\n\t\tthis._autoUpdate = !!value;\n\t}\n});\n\n/**\n * Starts emitting particles, and sets up the Emitter to destroy itself\n * when particle emission is complete.\n * @method PIXI.particles.Emitter#playOnceAndDestroy\n * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n */\np.playOnceAndDestroy = function(callback)\n{\n\tthis.emit = true;\n\tthis._destroyWhenComplete = true;\n\tthis._completeCallback = callback;\n};\n\n/**\n * Starts emitting particles, and optionally calls a callback\n * when particle emission is complete.\n * @method PIXI.particles.Emitter#playOnce\n * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n */\np.playOnce = function(callback)\n{\n\tthis.emit = true;\n\tthis._completeCallback = callback;\n};\n\n/**\n * Updates all particles spawned by this emitter and emits new ones.\n * @method PIXI.particles.Emitter#update\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n */\np.update = function(delta)\n{\n\tif (this._autoUpdate)\n\t{\n\t\tdelta = delta / PIXI.settings.TARGET_FPMS / 1000;\n\t}\n\n\t//if we don't have a parent to add particles to, then don't do anything.\n\t//this also works as a isDestroyed check\n\tif (!this._parent) return;\n\t//update existing particles\n\tvar i, particle, next;\n\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t{\n\t\tnext = particle.next;\n\t\tparticle.update(delta);\n\t}\n\tvar prevX, prevY;\n\t//if the previous position is valid, store these for later interpolation\n\tif(this._prevPosIsValid)\n\t{\n\t\tprevX = this._prevEmitterPos.x;\n\t\tprevY = this._prevEmitterPos.y;\n\t}\n\t//store current position of the emitter as local variables\n\tvar curX = this.ownerPos.x + this.spawnPos.x;\n\tvar curY = this.ownerPos.y + this.spawnPos.y;\n\t//spawn new particles\n\tif (this._emit)\n\t{\n\t\t//decrease spawn timer\n\t\tthis._spawnTimer -= delta;\n\t\t//while _spawnTimer < 0, we have particles to spawn\n\t\twhile(this._spawnTimer <= 0)\n\t\t{\n\t\t\t//determine if the emitter should stop spawning\n\t\t\tif(this._emitterLife > 0)\n\t\t\t{\n\t\t\t\tthis._emitterLife -= this._frequency;\n\t\t\t\tif(this._emitterLife <= 0)\n\t\t\t\t{\n\t\t\t\t\tthis._spawnTimer = 0;\n\t\t\t\t\tthis._emitterLife = 0;\n\t\t\t\t\tthis.emit = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//determine if we have hit the particle limit\n\t\t\tif(this.particleCount >= this.maxParticles)\n\t\t\t{\n\t\t\t\tthis._spawnTimer += this._frequency;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//determine the particle lifetime\n\t\t\tvar lifetime;\n\t\t\tif (this.minLifetime == this.maxLifetime)\n\t\t\t\tlifetime = this.minLifetime;\n\t\t\telse\n\t\t\t\tlifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\n\t\t\t//only make the particle if it wouldn't immediately destroy itself\n\t\t\tif(-this._spawnTimer < lifetime)\n\t\t\t{\n\t\t\t\t//If the position has changed and this isn't the first spawn,\n\t\t\t\t//interpolate the spawn position\n\t\t\t\tvar emitPosX, emitPosY;\n\t\t\t\tif (this._prevPosIsValid && this._posChanged)\n\t\t\t\t{\n\t\t\t\t\t//1 - _spawnTimer / delta, but _spawnTimer is negative\n\t\t\t\t\tvar lerp = 1 + this._spawnTimer / delta;\n\t\t\t\t\temitPosX = (curX - prevX) * lerp + prevX;\n\t\t\t\t\temitPosY = (curY - prevY) * lerp + prevY;\n\t\t\t\t}\n\t\t\t\telse//otherwise just set to the spawn position\n\t\t\t\t{\n\t\t\t\t\temitPosX = curX;\n\t\t\t\t\temitPosY = curY;\n\t\t\t\t}\n\t\t\t\t//create enough particles to fill the wave (non-burst types have a wave of 1)\n\t\t\t\ti = 0;\n\t\t\t\tfor(var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i)\n\t\t\t\t{\n\t\t\t\t\t//create particle\n\t\t\t\t\tvar p, rand;\n\t\t\t\t\tif(this._poolFirst)\n\t\t\t\t\t{\n\t\t\t\t\t\tp = this._poolFirst;\n\t\t\t\t\t\tthis._poolFirst = this._poolFirst.next;\n\t\t\t\t\t\tp.next = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp = new this.particleConstructor(this);\n\t\t\t\t\t}\n\n\t\t\t\t\t//set a random texture if we have more than one\n\t\t\t\t\tif(this.particleImages.length > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//if they are actually the same texture, a standard particle\n\t\t\t\t\t\t//will quit early from the texture setting in setTexture().\n\t\t\t\t\t\tp.applyArt(this.particleImages[0]);\n\t\t\t\t\t}\n\t\t\t\t\t//set up the start and end values\n\t\t\t\t\tp.startAlpha = this.startAlpha;\n\t\t\t\t\tp.endAlpha = this.endAlpha;\n\t\t\t\t\tif(this.minimumSpeedMultiplier != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trand = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\n\t\t\t\t\t\tp.startSpeed = this.startSpeed * rand;\n\t\t\t\t\t\tp.endSpeed = this.endSpeed * rand;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp.startSpeed = this.startSpeed;\n\t\t\t\t\t\tp.endSpeed = this.endSpeed;\n\t\t\t\t\t}\n\t\t\t\t\tp.acceleration.x = this.acceleration.x;\n\t\t\t\t\tp.acceleration.y = this.acceleration.y;\n\t\t\t\t\tp.maxSpeed = this.maxSpeed;\n\t\t\t\t\tif(this.minimumScaleMultiplier != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trand = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\n\t\t\t\t\t\tp.startScale = this.startScale * rand;\n\t\t\t\t\t\tp.endScale = this.endScale * rand;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp.startScale = this.startScale;\n\t\t\t\t\t\tp.endScale = this.endScale;\n\t\t\t\t\t}\n\t\t\t\t\tp.startColor = this.startColor;\n\t\t\t\t\tp.endColor = this.endColor;\n\t\t\t\t\t//randomize the rotation speed\n\t\t\t\t\tif(this.minRotationSpeed == this.maxRotationSpeed)\n\t\t\t\t\t\tp.rotationSpeed = this.minRotationSpeed;\n\t\t\t\t\telse\n\t\t\t\t\t\tp.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\n\t\t\t\t\tp.noRotation = this.noRotation;\n\t\t\t\t\t//set up the lifetime\n\t\t\t\t\tp.maxLife = lifetime;\n\t\t\t\t\t//set the blend mode\n\t\t\t\t\tp.blendMode = this.particleBlendMode;\n\t\t\t\t\t//set the custom ease, if any\n\t\t\t\t\tp.ease = this.customEase;\n\t\t\t\t\t//set the extra data, if any\n\t\t\t\t\tp.extraData = this.extraData;\n\t\t\t\t\t//call the proper function to handle rotation and position of particle\n\t\t\t\t\tthis._spawnFunc(p, emitPosX, emitPosY, i);\n\t\t\t\t\t//initialize particle\n\t\t\t\t\tp.init();\n\t\t\t\t\t//update the particle by the time passed, so the particles are spread out properly\n\t\t\t\t\tp.update(-this._spawnTimer);//we want a positive delta, because a negative delta messes things up\n\t\t\t\t\t//add the particle to the display list\n\t\t\t\t\tif(!this._parentIsPC || !p.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.addAtBack)\n\t\t\t\t\t\t\tthis._parent.addChildAt(p, 0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthis._parent.addChild(p);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//kind of hacky, but performance friendly\n\t\t\t\t\t\t//shuffle children to correct place\n\t\t\t\t\t\tvar children = this._parent.children;\n\t\t\t\t\t\t//avoid using splice if possible\n\t\t\t\t\t\tif(children[0] == p)\n\t\t\t\t\t\t\tchildren.shift();\n\t\t\t\t\t\telse if(children[children.length-1] == p)\n\t\t\t\t\t\t\tchildren.pop();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar index = children.indexOf(p);\n\t\t\t\t\t\t\tchildren.splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.addAtBack)\n\t\t\t\t\t\t\tchildren.unshift(p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tchildren.push(p);\n\t\t\t\t\t}\n\t\t\t\t\t//add particle to list of active particles\n\t\t\t\t\tif(this._activeParticlesLast)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._activeParticlesLast.next = p;\n\t\t\t\t\t\tp.prev = this._activeParticlesLast;\n\t\t\t\t\t\tthis._activeParticlesLast = p;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._activeParticlesLast = this._activeParticlesFirst = p;\n\t\t\t\t\t}\n\t\t\t\t\t++this.particleCount;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//increase timer and continue on to any other particles that need to be created\n\t\t\tthis._spawnTimer += this._frequency;\n\t\t}\n\t}\n\t//if the position changed before this update, then keep track of that\n\tif(this._posChanged)\n\t{\n\t\tthis._prevEmitterPos.x = curX;\n\t\tthis._prevEmitterPos.y = curY;\n\t\tthis._prevPosIsValid = true;\n\t\tthis._posChanged = false;\n\t}\n\n\t//if we are all done and should destroy ourselves, take care of that\n\tif (!this._emit && !this._activeParticlesFirst)\n\t{\n\t\tif (this._completeCallback)\n\t\t{\n\t\t\tthis._completeCallback();\n\t\t}\n\t\tif (this._destroyWhenComplete)\n\t\t{\n\t\t\tthis.destroy();\n\t\t}\n\t}\n};\n\n/**\n * Positions a particle for a point type emitter.\n * @method PIXI.particles.Emitter#_spawnPoint\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnPoint = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on\n\t//starting particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t//drop the particle at the emitter's position\n\tp.position.x = emitPosX;\n\tp.position.y = emitPosY;\n};\n\n/**\n * Positions a particle for a rectangle type emitter.\n * @method PIXI.particles.Emitter#_spawnRect\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnRect = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n\t//place the particle at a random point in the rectangle\n\thelperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\n\thelperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a circle type emitter.\n * @method PIXI.particles.Emitter#_spawnCircle\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnCircle = function(p, emitPosX, emitPosY)\n{\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t//place the particle at a random radius in the circle\n\thelperPoint.x = Math.random() * this.spawnCircle.radius;\n\thelperPoint.y = 0;\n\t//rotate the point to a random angle in the circle\n\tParticleUtils.rotatePoint(Math.random() * 360, helperPoint);\n\t//offset by the circle's center\n\thelperPoint.x += this.spawnCircle.x;\n\thelperPoint.y += this.spawnCircle.y;\n\t//rotate the point by the emitter's rotation\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t//set the position, offset by the emitter's position\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a ring type emitter.\n * @method PIXI.particles.Emitter#_spawnRing\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave. Not used for this function.\n */\np._spawnRing = function(p, emitPosX, emitPosY)\n{\n\tvar spawnCircle = this.spawnCircle;\n\t//set the initial rotation/direction of the particle based on starting\n\t//particle angle and rotation of emitter\n\tif (this.minStartRotation == this.maxStartRotation)\n\t\tp.rotation = this.minStartRotation + this.rotation;\n\telse\n\t\tp.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n\t\t\t\t\tthis.minStartRotation + this.rotation;\n\t//place the particle at a random radius in the ring\n\tif(spawnCircle.minRadius == spawnCircle.radius)\n\t{\n\t\thelperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\n\t\t\t\t\t\tspawnCircle.minRadius;\n\t}\n\telse\n\t\thelperPoint.x = spawnCircle.radius;\n\thelperPoint.y = 0;\n\t//rotate the point to a random angle in the circle\n\tvar angle = Math.random() * 360;\n\tp.rotation += angle;\n\tParticleUtils.rotatePoint(angle, helperPoint);\n\t//offset by the circle's center\n\thelperPoint.x += this.spawnCircle.x;\n\thelperPoint.y += this.spawnCircle.y;\n\t//rotate the point by the emitter's rotation\n\tif(this.rotation !== 0)\n\t\tParticleUtils.rotatePoint(this.rotation, helperPoint);\n\t//set the position, offset by the emitter's position\n\tp.position.x = emitPosX + helperPoint.x;\n\tp.position.y = emitPosY + helperPoint.y;\n};\n\n/**\n * Positions a particle for a burst type emitter.\n * @method PIXI.particles.Emitter#_spawnBurst\n * @private\n * @param {Particle} p The particle to position and rotate.\n * @param {Number} emitPosX The emitter's x position\n * @param {Number} emitPosY The emitter's y position\n * @param {int} i The particle number in the current wave.\n */\np._spawnBurst = function(p, emitPosX, emitPosY, i)\n{\n\t//set the initial rotation/direction of the particle based on spawn\n\t//angle and rotation of emitter\n\tif(this.particleSpacing === 0)\n\t\tp.rotation = Math.random() * 360;\n\telse\n\t\tp.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\n\t//drop the particle at the emitter's position\n\tp.position.x = emitPosX;\n\tp.position.y = emitPosY;\n};\n\n/**\n * Kills all active particles immediately.\n * @method PIXI.particles.Emitter#cleanup\n */\np.cleanup = function()\n{\n\tvar particle, next;\n\tfor (particle = this._activeParticlesFirst; particle; particle = next)\n\t{\n\t\tnext = particle.next;\n\t\tthis.recycle(particle);\n\t\tif(particle.parent)\n\t\t\tparticle.parent.removeChild(particle);\n\t}\n\tthis._activeParticlesFirst = this._activeParticlesLast = null;\n\tthis.particleCount = 0;\n};\n\n/**\n * Destroys the emitter and all of its particles.\n * @method PIXI.particles.Emitter#destroy\n */\np.destroy = function()\n{\n\t//make sure we aren't still listening to any tickers\n\tthis.autoUpdate = false;\n\t//puts all active particles in the pool, and removes them from the particle parent\n\tthis.cleanup();\n\t//wipe the pool clean\n\tvar next;\n\tfor (var particle = this._poolFirst; particle; particle = next)\n\t{\n\t\t//store next value so we don't lose it in our destroy call\n\t\tnext = particle.next;\n\t\tparticle.destroy();\n\t}\n\tthis._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\n\t\tthis.startColor = this.endColor = this.customEase = this._completeCallback = null;\n};\n\nmodule.exports = Emitter;","var ParticleUtils = require(\"./ParticleUtils\");\r\nvar Sprite = PIXI.Sprite;\r\n\r\n/**\r\n * An individual particle image. You shouldn't have to deal with these.\r\n * @memberof PIXI.particles\r\n * @class Particle\r\n * @extends PIXI.Sprite\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\r\n */\r\nvar Particle = function(emitter)\r\n{\r\n\t//start off the sprite with a blank texture, since we are going to replace it\r\n\t//later when the particle is initialized.\r\n\tSprite.call(this);\r\n\r\n\t/**\r\n\t * The emitter that controls this particle.\r\n\t * @property {Emitter} emitter\r\n\t */\r\n\tthis.emitter = emitter;\r\n\t//particles should be centered\r\n\tthis.anchor.x = this.anchor.y = 0.5;\r\n\t/**\r\n\t * The velocity of the particle. Speed may change, but the angle also\r\n\t * contained in velocity is constant.\r\n\t * @property {PIXI.Point} velocity\r\n\t */\r\n\tthis.velocity = new PIXI.Point();\r\n\t/**\r\n\t * The maximum lifetime of this particle, in seconds.\r\n\t * @property {Number} maxLife\r\n\t */\r\n\tthis.maxLife = 0;\r\n\t/**\r\n\t * The current age of the particle, in seconds.\r\n\t * @property {Number} age\r\n\t */\r\n\tthis.age = 0;\r\n\t/**\r\n\t * A simple easing function to be applied to all properties that\r\n\t * are being interpolated.\r\n\t * @property {Function} ease\r\n\t */\r\n\tthis.ease = null;\r\n\t/**\r\n\t * Extra data that the emitter passes along for custom particles.\r\n\t * @property {Object} extraData\r\n\t */\r\n\tthis.extraData = null;\r\n\t/**\r\n\t * The alpha of the particle at the start of its life.\r\n\t * @property {Number} startAlpha\r\n\t */\r\n\tthis.startAlpha = 0;\r\n\t/**\r\n\t * The alpha of the particle at the end of its life.\r\n\t * @property {Number} endAlpha\r\n\t */\r\n\tthis.endAlpha = 0;\r\n\t/**\r\n\t * The speed of the particle at the start of its life.\r\n\t * @property {Number} startSpeed\r\n\t */\r\n\tthis.startSpeed = 0;\r\n\t/**\r\n\t * The speed of the particle at the end of its life.\r\n\t * @property {Number} endSpeed\r\n\t */\r\n\tthis.endSpeed = 0;\r\n\t/**\r\n\t * Acceleration to apply to the particle.\r\n\t * @property {PIXI.Point} accleration\r\n\t */\r\n\tthis.acceleration = new PIXI.Point();\r\n\t/**\r\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r\n\t * will disable the maximum speed.\r\n\t * @property {Number} maxSpeed\r\n\t * @default NaN\r\n\t */\r\n\tthis.maxSpeed = NaN;\r\n\t/**\r\n\t * The scale of the particle at the start of its life.\r\n\t * @property {Number} startScale\r\n\t */\r\n\tthis.startScale = 0;\r\n\t/**\r\n\t * The scale of the particle at the start of its life.\r\n\t * @property {Number} endScale\r\n\t */\r\n\tthis.endScale = 0;\r\n\t/**\r\n\t * The tint of the particle at the start of its life.\r\n\t * @property {Array} startColor\r\n\t */\r\n\tthis.startColor = null;\r\n\t/**\r\n\t * The red tint of the particle at the start of its life.\r\n\t * This is pulled from startColor in init().\r\n\t * @property {uint} _sR\r\n\t * @private\r\n\t */\r\n\tthis._sR = 0;\r\n\t/**\r\n\t * The green tint of the particle at the start of its life.\r\n\t * This is pulled from startColor in init().\r\n\t * @property {uint} _sG\r\n\t * @private\r\n\t */\r\n\tthis._sG = 0;\r\n\t/**\r\n\t * The blue tint of the particle at the start of its life.\r\n\t * This is pulled from startColor in init().\r\n\t * @property {uint} _sB\r\n\t * @private\r\n\t */\r\n\tthis._sB = 0;\r\n\t/**\r\n\t * The tint of the particle at the start of its life.\r\n\t * @property {Array} endColor\r\n\t */\r\n\tthis.endColor = null;\r\n\t/**\r\n\t * The red tint of the particle at the end of its life.\r\n\t * This is pulled from endColor in init().\r\n\t * @property {uint} _eR\r\n\t * @private\r\n\t */\r\n\tthis._eR = 0;\r\n\t/**\r\n\t * The green tint of the particle at the end of its life.\r\n\t * This is pulled from endColor in init().\r\n\t * @property {uint} _sG\r\n\t * @private\r\n\t */\r\n\tthis._eG = 0;\r\n\t/**\r\n\t * The blue tint of the particle at the end of its life.\r\n\t * This is pulled from endColor in init().\r\n\t * @property {uint} _sB\r\n\t * @private\r\n\t */\r\n\tthis._eB = 0;\r\n\t/**\r\n\t * If alpha should be interpolated at all.\r\n\t * @property {Boolean} _doAlpha\r\n\t * @private\r\n\t */\r\n\tthis._doAlpha = false;\r\n\t/**\r\n\t * If scale should be interpolated at all.\r\n\t * @property {Boolean} _doScale\r\n\t * @private\r\n\t */\r\n\tthis._doScale = false;\r\n\t/**\r\n\t * If speed should be interpolated at all.\r\n\t * @property {Boolean} _doSpeed\r\n\t * @private\r\n\t */\r\n\tthis._doSpeed = false;\r\n\t/**\r\n\t * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\r\n\t * and _doSpeed gets priority.\r\n\t * @property {Boolean} _doAcceleration\r\n\t * @private\r\n\t */\r\n\tthis._doAcceleration = false;\r\n\t/**\r\n\t * If color should be interpolated at all.\r\n\t * @property {Boolean} _doColor\r\n\t * @private\r\n\t */\r\n\tthis._doColor = false;\r\n\t/**\r\n\t * If normal movement should be handled. Subclasses wishing to override movement\r\n\t * can set this to false in init().\r\n\t * @property {Boolean} _doNormalMovement\r\n\t * @private\r\n\t */\r\n\tthis._doNormalMovement = false;\r\n\t/**\r\n\t * One divided by the max life of the particle, saved for slightly faster math.\r\n\t * @property {Number} _oneOverLife\r\n\t * @private\r\n\t */\r\n\tthis._oneOverLife = 0;\r\n\r\n\t/**\r\n\t * Reference to the next particle in the list.\r\n\t * @property {Particle} next\r\n\t * @private\r\n\t */\r\n\tthis.next = null;\r\n\r\n\t/**\r\n\t * Reference to the previous particle in the list.\r\n\t * @property {Particle} prev\r\n\t * @private\r\n\t */\r\n\tthis.prev = null;\r\n\r\n\t//save often used functions on the instance instead of the prototype for better speed\r\n\tthis.init = this.init;\r\n\tthis.Particle_init = this.Particle_init;\r\n\tthis.update = this.update;\r\n\tthis.Particle_update = this.Particle_update;\r\n\tthis.applyArt = this.applyArt;\r\n\tthis.kill = this.kill;\r\n};\r\n\r\n// Reference to the prototype\r\nvar p = Particle.prototype = Object.create(Sprite.prototype);\r\n\r\n/**\r\n * Initializes the particle for use, based on the properties that have to\r\n * have been set already on the particle.\r\n * @method PIXI.particles.Particle#init\r\n */\r\n/**\r\n * A reference to init, so that subclasses can access it without the penalty of Function.call()\r\n * @method PIXI.particles.Particle#Particle_init\r\n * @protected\r\n */\r\np.init = p.Particle_init = function()\r\n{\r\n\t//reset the age\r\n\tthis.age = 0;\r\n\t//set up the velocity based on the start speed and rotation\r\n\tthis.velocity.x = this.startSpeed;\r\n\tthis.velocity.y = 0;\r\n\tParticleUtils.rotatePoint(this.rotation, this.velocity);\r\n\tif (this.noRotation)\r\n\t{\r\n\t\tthis.rotation = 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//convert rotation to Radians from Degrees\r\n\t\tthis.rotation *= ParticleUtils.DEG_TO_RADS;\r\n\t}\r\n\t//convert rotation speed to Radians from Degrees\r\n\tthis.rotationSpeed *= ParticleUtils.DEG_TO_RADS;\r\n\t//set alpha to inital alpha\r\n\tthis.alpha = this.startAlpha;\r\n\t//set scale to initial scale\r\n\tthis.scale.x = this.scale.y = this.startScale;\r\n\t//determine start and end color values\r\n\tif (this.startColor)\r\n\t{\r\n\t\tthis._sR = this.startColor[0];\r\n\t\tthis._sG = this.startColor[1];\r\n\t\tthis._sB = this.startColor[2];\r\n\t\tif(this.endColor)\r\n\t\t{\r\n\t\t\tthis._eR = this.endColor[0];\r\n\t\t\tthis._eG = this.endColor[1];\r\n\t\t\tthis._eB = this.endColor[2];\r\n\t\t}\r\n\t}\r\n\t//figure out what we need to interpolate\r\n\tthis._doAlpha = this.startAlpha != this.endAlpha;\r\n\tthis._doSpeed = this.startSpeed != this.endSpeed;\r\n\tthis._doScale = this.startScale != this.endScale;\r\n\tthis._doColor = !!this.endColor;\r\n\tthis._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\r\n\t//_doNormalMovement can be cancelled by subclasses\r\n\tthis._doNormalMovement = this._doSpeed || this.startSpeed !== 0 || this._doAcceleration;\r\n\t//save our lerp helper\r\n\tthis._oneOverLife = 1 / this.maxLife;\r\n\t//set the inital color\r\n\tthis.tint = ParticleUtils.combineRGBComponents(this._sR, this._sG, this._sB);\r\n\t//ensure visibility\r\n\tthis.visible = true;\r\n};\r\n\r\n/**\r\n * Sets the texture for the particle. This can be overridden to allow\r\n * for an animated particle.\r\n * @method PIXI.particles.Particle#applyArt\r\n * @param {PIXI.Texture} art The texture to set.\r\n */\r\np.applyArt = function(art)\r\n{\r\n\tthis.texture = art || ParticleUtils.EMPTY_TEXTURE;\r\n};\r\n\r\n/**\r\n * Updates the particle.\r\n * @method PIXI.particles.Particle#update\r\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\r\n *                   properties. A value of -1 means the particle died of old age instead.\r\n */\r\n/**\r\n * A reference to update so that subclasses can access the original without the overhead\r\n * of Function.call().\r\n * @method PIXI.particles.Particle#Particle_update\r\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\r\n *                   properties. A value of -1 means the particle died of old age instead.\r\n * @protected\r\n */\r\np.update = p.Particle_update = function(delta)\r\n{\r\n\t//increase age\r\n\tthis.age += delta;\r\n\t//recycle particle if it is too old\r\n\tif(this.age >= this.maxLife)\r\n\t{\r\n\t\tthis.kill();\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t//determine our interpolation value\r\n\tvar lerp = this.age * this._oneOverLife;//lifetime / maxLife;\r\n\tif (this.ease)\r\n\t{\r\n\t\tif(this.ease.length == 4)\r\n\t\t{\r\n\t\t\t//the t, b, c, d parameters that some tween libraries use\r\n\t\t\t//(time, initial value, end value, duration)\r\n\t\t\tlerp = this.ease(lerp, 0, 1, 1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//the simplified version that we like that takes\r\n\t\t\t//one parameter, time from 0-1. TweenJS eases provide this usage.\r\n\t\t\tlerp = this.ease(lerp);\r\n\t\t}\r\n\t}\r\n\r\n\t//interpolate alpha\r\n\tif (this._doAlpha)\r\n\t\tthis.alpha = (this.endAlpha - this.startAlpha) * lerp + this.startAlpha;\r\n\t//interpolate scale\r\n\tif (this._doScale)\r\n\t{\r\n\t\tvar scale = (this.endScale - this.startScale) * lerp + this.startScale;\r\n\t\tthis.scale.x = this.scale.y = scale;\r\n\t}\r\n\t//handle movement\r\n\tif(this._doNormalMovement)\r\n\t{\r\n\t\t//interpolate speed\r\n\t\tif (this._doSpeed)\r\n\t\t{\r\n\t\t\tvar speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;\r\n\t\t\tParticleUtils.normalize(this.velocity);\r\n\t\t\tParticleUtils.scaleBy(this.velocity, speed);\r\n\t\t}\r\n\t\telse if(this._doAcceleration)\r\n\t\t{\r\n\t\t\tthis.velocity.x += this.acceleration.x * delta;\r\n\t\t\tthis.velocity.y += this.acceleration.y * delta;\r\n\t\t\tif (this.maxSpeed)\r\n\t\t\t{\r\n\t\t\t\tvar currentSpeed = ParticleUtils.length(this.velocity);\r\n\t\t\t\t//if we are going faster than we should, clamp at the max speed\r\n\t\t\t\t//DO NOT recalculate vector length\r\n\t\t\t\tif (currentSpeed > this.maxSpeed)\r\n\t\t\t\t{\r\n\t\t\t\t\tParticleUtils.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//adjust position based on velocity\r\n\t\tthis.position.x += this.velocity.x * delta;\r\n\t\tthis.position.y += this.velocity.y * delta;\r\n\t}\r\n\t//interpolate color\r\n\tif (this._doColor)\r\n\t{\r\n\t\tvar r = (this._eR - this._sR) * lerp + this._sR;\r\n\t\tvar g = (this._eG - this._sG) * lerp + this._sG;\r\n\t\tvar b = (this._eB - this._sB) * lerp + this._sB;\r\n\t\tthis.tint = ParticleUtils.combineRGBComponents(r, g, b);\r\n\t}\r\n\t//update rotation\r\n\tif(this.rotationSpeed !== 0)\r\n\t{\r\n\t\tthis.rotation += this.rotationSpeed * delta;\r\n\t}\r\n\telse if(this.acceleration && !this.noRotation)\r\n\t{\r\n\t\tthis.rotation = Math.atan2(this.velocity.y, this.velocity.x);// + Math.PI / 2;\r\n\t}\r\n\treturn lerp;\r\n};\r\n\r\n/**\r\n * Kills the particle, removing it from the display list\r\n * and telling the emitter to recycle it.\r\n * @method PIXI.particles.Particle#kill\r\n */\r\np.kill = function()\r\n{\r\n\tthis.emitter.recycle(this);\r\n};\r\n\r\np.Sprite_Destroy = Sprite.prototype.destroy;\r\n/**\r\n * Destroys the particle, removing references and preventing future use.\r\n * @method PIXI.particles.Particle#destroy\r\n */\r\np.destroy = function()\r\n{\r\n\tif (this.parent)\r\n\t\tthis.parent.removeChild(this);\r\n\tif (this.Sprite_Destroy)\r\n\t\tthis.Sprite_Destroy();\r\n\tthis.emitter = this.velocity = this.startColor = this.endColor = this.ease =\r\n\t\tthis.next = this.prev = null;\r\n};\r\n\r\n/**\r\n * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n * modifications to prepare it ahead of time.\r\n * @method PIXI.particles.Particle.parseArt\r\n * @static\r\n * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\r\n *                     Any strings in the array will be converted to Textures via\r\n *                     Texture.fromImage().\r\n * @return {Array} The art, after any needed modifications.\r\n */\r\nParticle.parseArt = function(art)\r\n{\r\n\t//convert any strings to Textures.\r\n\tvar i;\r\n\tfor(i = art.length; i >= 0; --i)\r\n\t{\r\n\t\tif(typeof art[i] == \"string\")\r\n\t\t\tart[i] = PIXI.Texture.fromImage(art[i]);\r\n\t}\r\n\t//particles from different base textures will be slower in WebGL than if they\r\n\t//were from one spritesheet\r\n\tif(ParticleUtils.verbose)\r\n\t{\r\n\t\tfor(i = art.length - 1; i > 0; --i)\r\n\t\t{\r\n\t\t\tif(art[i].baseTexture != art[i - 1].baseTexture)\r\n\t\t\t{\r\n\t\t\t\tif (window.console)\r\n\t\t\t\t\tconsole.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn art;\r\n};\r\n\r\n/**\r\n * Parses extra emitter data to ensure it is set up for this particle class.\r\n * Particle does nothing to the extra data.\r\n * @method PIXI.particles.Particle.parseData\r\n * @static\r\n * @param  {Object} extraData The extra data from the particle config.\r\n * @return {Object} The parsed extra data.\r\n */\r\nParticle.parseData = function(extraData)\r\n{\r\n\treturn extraData;\r\n};\r\n\r\nmodule.exports = Particle;","\"use strict\";\r\n\r\nvar BLEND_MODES = PIXI.BLEND_MODES || PIXI.blendModes;\r\nvar Texture = PIXI.Texture;\r\n\r\n/**\r\n * Contains helper functions for particles and emitters to use.\r\n * @memberof PIXI.particles\r\n * @class ParticleUtils\r\n * @static\r\n */\r\nvar ParticleUtils = {};\r\n\r\n/**\r\n * If errors and warnings should be logged within the library.\r\n * @name PIXI.particles.ParticleUtils.verbose\r\n * @default false\r\n * @static\r\n */\r\nParticleUtils.verbose = false;\r\n\r\nvar DEG_TO_RADS = ParticleUtils.DEG_TO_RADS = Math.PI / 180;\r\n\r\nvar empty = ParticleUtils.EMPTY_TEXTURE = Texture.EMPTY;\r\n//prevent any events from being used on the empty texture, as well as destruction of it\r\n//v4 of Pixi does this, but doing it again won't hurt\r\nempty.on = empty.destroy = empty.once = empty.emit = function() {};\r\n\r\n/**\r\n * Rotates a point by a given angle.\r\n * @method PIXI.particles.ParticleUtils.rotatePoint\r\n * @param {Number} angle The angle to rotate by in degrees\r\n * @param {PIXI.Point} p The point to rotate around 0,0.\r\n * @static\r\n */\r\nParticleUtils.rotatePoint = function(angle, p)\r\n{\r\n\tif(!angle) return;\r\n\tangle *= DEG_TO_RADS;\r\n\tvar s = Math.sin(angle);\r\n\tvar c = Math.cos(angle);\r\n\tvar xnew = p.x * c - p.y * s;\r\n\tvar ynew = p.x * s + p.y * c;\r\n\tp.x = xnew;\r\n\tp.y = ynew;\r\n};\r\n\r\n/**\r\n * Combines separate color components (0-255) into a single uint color.\r\n * @method PIXI.particles.ParticleUtils.combineRGBComponents\r\n * @param {uint} r The red value of the color\r\n * @param {uint} g The green value of the color\r\n * @param {uint} b The blue value of the color\r\n * @return {uint} The color in the form of 0xRRGGBB\r\n * @static\r\n */\r\nParticleUtils.combineRGBComponents = function(r, g, b/*, a*/)\r\n{\r\n\treturn /*a << 24 |*/ r << 16 | g << 8 | b;\r\n};\r\n\r\n/**\r\n * Reduces the point to a length of 1.\r\n * @method PIXI.particles.ParticleUtils.normalize\r\n * @static\r\n * @param {PIXI.Point} point The point to normalize\r\n */\r\nParticleUtils.normalize = function(point)\r\n{\r\n\tvar oneOverLen = 1 / ParticleUtils.length(point);\r\n\tpoint.x *= oneOverLen;\r\n\tpoint.y *= oneOverLen;\r\n};\r\n\r\n/**\r\n * Multiplies the x and y values of this point by a value.\r\n * @method PIXI.particles.ParticleUtils.scaleBy\r\n * @static\r\n * @param {PIXI.Point} point The point to scaleBy\r\n * @param value {Number} The value to scale by.\r\n */\r\nParticleUtils.scaleBy = function(point, value)\r\n{\r\n\tpoint.x *= value;\r\n\tpoint.y *= value;\r\n};\r\n\r\n/**\r\n * Returns the length (or magnitude) of this point.\r\n * @method PIXI.particles.ParticleUtils.length\r\n * @static\r\n * @param {PIXI.Point} point The point to measure length\r\n * @return The length of this point.\r\n */\r\nParticleUtils.length = function(point)\r\n{\r\n\treturn Math.sqrt(point.x * point.x + point.y * point.y);\r\n};\r\n\r\n/**\r\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\r\n * \"AARRGGBB\", or \"RRGGBB\" to an array of ints of 0-255 or Numbers from 0-1, as\r\n * [r, g, b, (a)].\r\n * @method PIXI.particles.ParticleUtils.hexToRGB\r\n * @param {String} color The input color string.\r\n * @param {Array} output An array to put the output in. If omitted, a new array is created.\r\n * @return The array of numeric color values.\r\n * @static\r\n */\r\nParticleUtils.hexToRGB = function(color, output)\r\n{\r\n\tif (output)\r\n\t\toutput.length = 0;\r\n\telse\r\n\t\toutput = [];\r\n\tif (color.charAt(0) == \"#\")\r\n\t\tcolor = color.substr(1);\r\n\telse if (color.indexOf(\"0x\") === 0)\r\n\t\tcolor = color.substr(2);\r\n\tvar alpha;\r\n\tif (color.length == 8)\r\n\t{\r\n\t\talpha = color.substr(0, 2);\r\n\t\tcolor = color.substr(2);\r\n\t}\r\n\toutput.push(parseInt(color.substr(0, 2), 16));//Red\r\n\toutput.push(parseInt(color.substr(2, 2), 16));//Green\r\n\toutput.push(parseInt(color.substr(4, 2), 16));//Blue\r\n\tif (alpha)\r\n\t\toutput.push(parseInt(alpha, 16));\r\n\treturn output;\r\n};\r\n\r\n/**\r\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\r\n * by the related tool at http://www.greensock.com/customease/.\r\n * @method PIXI.particles.ParticleUtils.generateEase\r\n * @param {Array} segments An array of segments, as created by\r\n * http://www.greensock.com/customease/.\r\n * @return {Function} A function that calculates the percentage of change at\r\n *                    a given point in time (0-1 inclusive).\r\n * @static\r\n */\r\nParticleUtils.generateEase = function(segments)\r\n{\r\n\tvar qty = segments.length;\r\n\tvar oneOverQty = 1 / qty;\r\n\t/*\r\n\t * Calculates the percentage of change at a given point in time (0-1 inclusive).\r\n\t * @param {Number} time The time of the ease, 0-1 inclusive.\r\n\t * @return {Number} The percentage of the change, 0-1 inclusive (unless your\r\n\t *                  ease goes outside those bounds).\r\n\t */\r\n\tvar simpleEase = function(time)\r\n\t{\r\n\t\tvar t, s;\r\n\t\tvar i = (qty * time) | 0;//do a quick floor operation\r\n\t\tt = (time - (i * oneOverQty)) * qty;\r\n\t\ts = segments[i] || segments[qty - 1];\r\n\t\treturn (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\r\n\t};\r\n\treturn simpleEase;\r\n};\r\n\r\n/**\r\n * Gets a blend mode, ensuring that it is valid.\r\n * @method PIXI.particles.ParticleUtils.getBlendMode\r\n * @param {String} name The name of the blend mode to get.\r\n * @return {int} The blend mode as specified in the PIXI.blendModes enumeration.\r\n * @static\r\n */\r\nParticleUtils.getBlendMode = function(name)\r\n{\r\n\tif (!name) return BLEND_MODES.NORMAL;\r\n\tname = name.toUpperCase();\r\n\twhile (name.indexOf(\" \") >= 0)\r\n\t\tname = name.replace(\" \", \"_\");\r\n\treturn BLEND_MODES[name] || BLEND_MODES.NORMAL;\r\n};\r\n\r\nmodule.exports = ParticleUtils;","\"use strict\";\r\n\r\nvar ParticleUtils = require(\"./ParticleUtils\"),\r\n\tParticle = require(\"./Particle\");\r\n\r\n/**\r\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\r\n * \"5x + 3\".\r\n * To use this class, the particle config must have a \"path\" string in the\r\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\r\n * speed settings of the particle). It may have numbers, parentheses, the four basic\r\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\r\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\r\n * \"acos\", \"atan\", \"atan2\", \"log\".\r\n * The overall movement of the particle and the expression value become x and y positions for\r\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\r\n * the particle.\r\n *\r\n * Some example paths:\r\n *\r\n * \t\"sin(x/10) * 20\" // A sine wave path.\r\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\r\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\r\n *\r\n * @memberof PIXI.particles\r\n * @class PathParticle\r\n * @extends PIXI.particles.Particle\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\r\n */\r\nvar PathParticle = function(emitter)\r\n{\r\n\tParticle.call(this, emitter);\r\n\t/**\r\n\t * The function representing the path the particle should take.\r\n\t * @property {Function} path\r\n\t */\r\n\tthis.path = null;\r\n\t/**\r\n\t * The initial rotation in degrees of the particle, because the direction of the path\r\n\t * is based on that.\r\n\t * @property {Number} initialRotation\r\n\t */\r\n\tthis.initialRotation = 0;\r\n\t/**\r\n\t * The initial position of the particle, as all path movement is added to that.\r\n\t * @property {PIXI.Point} initialPosition\r\n\t */\r\n\tthis.initialPosition = new PIXI.Point();\r\n\t/**\r\n\t * Total single directional movement, due to speed.\r\n\t * @property {Number} movement\r\n\t */\r\n\tthis.movement = 0;\r\n};\r\n\r\n// Reference to the super class\r\nvar s = Particle.prototype;\r\n// Reference to the prototype\r\nvar p = PathParticle.prototype = Object.create(s);\r\n\r\n/**\r\n * A helper point for math things.\r\n * @property {Function} helperPoint\r\n * @private\r\n * @static\r\n */\r\nvar helperPoint = new PIXI.Point();\r\n\r\n/**\r\n * Initializes the particle for use, based on the properties that have to\r\n * have been set already on the particle.\r\n * @method PIXI.particles.PathParticle#init\r\n */\r\np.init = function()\r\n{\r\n\t//get initial rotation before it is converted to radians\r\n\tthis.initialRotation = this.rotation;\r\n\t//standard init\r\n\tthis.Particle_init();\r\n\r\n\t//set the path for the particle\r\n\tthis.path = this.extraData.path;\r\n\t//cancel the normal movement behavior\r\n\tthis._doNormalMovement = !this.path;\r\n\t//reset movement\r\n\tthis.movement = 0;\r\n\t//grab position\r\n\tthis.initialPosition.x = this.position.x;\r\n\tthis.initialPosition.y = this.position.y;\r\n};\r\n\r\n//a hand picked list of Math functions (and a couple properties) that are allowable.\r\n//they should be used without the preceding \"Math.\"\r\nvar MATH_FUNCS =\r\n[\r\n\t\"pow\",\r\n\t\"sqrt\",\r\n\t\"abs\",\r\n\t\"floor\",\r\n\t\"round\",\r\n\t\"ceil\",\r\n\t\"E\",\r\n\t\"PI\",\r\n\t\"sin\",\r\n\t\"cos\",\r\n\t\"tan\",\r\n\t\"asin\",\r\n\t\"acos\",\r\n\t\"atan\",\r\n\t\"atan2\",\r\n\t\"log\"\r\n];\r\n//Allow the 4 basic operations, parentheses and all numbers/decimals, as well\r\n//as 'x', for the variable usage.\r\nvar WHITELISTER = \"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\";\r\n//add the math functions to the regex string.\r\nfor(var index = MATH_FUNCS.length - 1; index >= 0; --index)\r\n{\r\n\tWHITELISTER += \"|\" + MATH_FUNCS[index];\r\n}\r\n//create an actual regular expression object from the string\r\nWHITELISTER = new RegExp(WHITELISTER, \"g\");\r\n\r\n/**\r\n * Parses a string into a function for path following.\r\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\r\n * names, and using `new Function()` to generate a function.\r\n * @method PIXI.particles.PathParticle~parsePath\r\n * @private\r\n * @static\r\n * @param {String} pathString The string to parse.\r\n * @return {Function} The path function - takes x, outputs y.\r\n */\r\nvar parsePath = function(pathString)\r\n{\r\n\tvar matches = pathString.match(WHITELISTER);\r\n\tfor(var i = matches.length - 1; i >= 0; --i)\r\n\t{\r\n\t\tif(MATH_FUNCS.indexOf(matches[i]) >= 0)\r\n\t\t\tmatches[i] = \"Math.\" + matches[i];\r\n\t}\r\n\tpathString = matches.join(\"\");\r\n\treturn new Function(\"x\", \"return \"+ pathString + \";\");\r\n};\r\n\r\n/**\r\n * Updates the particle.\r\n * @method PIXI.particles.PathParticle#update\r\n * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n */\r\np.update = function(delta)\r\n{\r\n\tvar lerp = this.Particle_update(delta);\r\n\t//if the particle died during the update, then don't bother\r\n\tif(lerp >= 0 && this.path)\r\n\t{\r\n\t\t//increase linear movement based on speed\r\n\t\tvar speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;\r\n\t\tthis.movement += speed * delta;\r\n\t\t//set up the helper point for rotation\r\n\t\thelperPoint.x = this.movement;\r\n\t\thelperPoint.y = this.path(this.movement);\r\n\t\tParticleUtils.rotatePoint(this.initialRotation, helperPoint);\r\n\t\tthis.position.x = this.initialPosition.x + helperPoint.x;\r\n\t\tthis.position.y = this.initialPosition.y + helperPoint.y;\r\n\t}\r\n};\r\n\r\np.Particle_destroy = Particle.prototype.destroy;\r\n/**\r\n * Destroys the particle, removing references and preventing future use.\r\n * @method PIXI.particles.PathParticle#destroy\r\n */\r\np.destroy = function()\r\n{\r\n\tthis.Particle_destroy();\r\n\tthis.path = this.initialPosition = null;\r\n};\r\n\r\n/**\r\n * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n * modifications to prepare it ahead of time. This just runs Particle.parseArt().\r\n * @method PIXI.particles.PathParticle.parseArt\r\n * @static\r\n * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\r\n *                     Any strings in the array will be converted to Textures via\r\n *                     Texture.fromImage().\r\n * @return {Array} The art, after any needed modifications.\r\n */\r\nPathParticle.parseArt = function(art)\r\n{\r\n\treturn Particle.parseArt(art);\r\n};\r\n\r\n/**\r\n * Parses extra emitter data to ensure it is set up for this particle class.\r\n * PathParticle checks for the existence of path data, and parses the path data for use\r\n * by particle instances.\r\n * @method PIXI.particles.PathParticle.parseData\r\n * @static\r\n * @param  {Object} extraData The extra data from the particle config.\r\n * @return {Object} The parsed extra data.\r\n */\r\nPathParticle.parseData = function(extraData)\r\n{\r\n\tvar output = {};\r\n\tif(extraData && extraData.path)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\toutput.path = parsePath(extraData.path);\r\n\t\t}\r\n\t\tcatch(e)\r\n\t\t{\r\n\t\t\tif(ParticleUtils.verbose)\r\n\t\t\t\tconsole.error(\"PathParticle: error in parsing path expression\");\r\n\t\t\toutput.path = null;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(ParticleUtils.verbose)\r\n\t\t\tconsole.error(\"PathParticle requires a path string in extraData!\");\r\n\t\toutput.path = null;\r\n\t}\r\n\treturn output;\r\n};\r\n\r\nmodule.exports = PathParticle;","exports.ParticleUtils = require(\"./ParticleUtils.js\");\r\nexports.Particle = require(\"./Particle.js\");\r\nexports.Emitter = require(\"./Emitter.js\");\r\nexports.PathParticle = require(\"./PathParticle.js\");\r\nexports.AnimatedParticle = require(\"./AnimatedParticle.js\");\r\nrequire(\"./deprecation.js\");","\"use strict\";\r\n\r\n// Check for window, fallback to global\r\nvar global = typeof window !== 'undefined' ? window : GLOBAL;\r\n\r\n//ensure that the particles namespace exist - PIXI 4 creates it itself, PIXI 3 does not\r\nif (!global.PIXI.particles) {\r\n\tglobal.PIXI.particles = {};\r\n}\r\n\r\n// Export for Node-compatible environments like Electron\r\nif (typeof module !== 'undefined' && module.exports)\r\n{\r\n\t// Attempt to require the pixi module\r\n\tif (typeof PIXI === 'undefined')\r\n\t{\r\n\t\t// Include the Pixi.js module\r\n\t\trequire('pixi.js');\r\n\t}\r\n\r\n\t// Export the module\r\n\tmodule.exports = global.PIXI.particles || particles;\r\n}\r\n// If we're in the browser make sure PIXI is available\r\nelse if (typeof PIXI === 'undefined')\r\n{\r\n\tthrow \"pixi-particles requires pixi.js to be loaded first\";\r\n}\r\n\r\n// get the library itself\r\nvar particles = require('./particles');\r\n\r\n// insert the lirbary into the particles namespace on PIXI\r\nfor (var prop in particles) {\r\n\tglobal.PIXI.particles[prop] = particles[prop];\r\n}"],"sourceRoot":"."}