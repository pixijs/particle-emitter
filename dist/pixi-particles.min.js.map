{"version":3,"sources":["node_modules/browser-pack/_prelude.js","ts-dist/AnimatedParticle.js","ts-dist/Emitter.js","ts-dist/Particle.js","ts-dist/ParticleUtils.js","ts-dist/PathParticle.js","ts-dist/PolygonalChain.js","ts-dist/PropertyList.js","ts-dist/PropertyNode.js","ts-dist/particles.js","ts-dist"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiParticles","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","Particle_1","Texture","PIXI","AnimatedParticle","_super","emitter","_this","textures","duration","framerate","elapsed","loop","init","Particle_init","maxLife","applyArt","art","update","delta","lerp","Particle_update","frame","texture","EMPTY","destroy","Particle_destroy","parseArt","data","output","tex","outTextures","outArr","j","push","fromImage","dupe","count","default","ParticleUtils_1","PropertyNode_1","PolygonalChain_1","ticker","shared","helperPoint","Point","Emitter","particleParent","particleImages","config","_particleConstructor","startAlpha","startSpeed","minimumSpeedMultiplier","acceleration","maxSpeed","NaN","startScale","minimumScaleMultiplier","startColor","minLifetime","maxLifetime","minStartRotation","maxStartRotation","noRotation","minRotationSpeed","maxRotationSpeed","particleBlendMode","customEase","extraData","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","spawnType","_spawnFunc","spawnRect","spawnCircle","spawnPolygonalChain","particlesPerWave","particleSpacing","angleStart","rotation","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_origArt","_autoUpdate","_destroyWhenComplete","_completeCallback","parent","recycle","rotate","updateSpawnPos","updateOwnerPos","get","set","enumerable","configurable","cleanup","particle","next","isArray","slice","partClass","alpha","createList","speed","x","y","scale","color","startRotation","min","max","rotationSpeed","lifetime","getBlendMode","blendMode","ease","generateEase","parseData","_spawnRect","Rectangle","w","h","_spawnCircle","Circle","_spawnRing","minRadius","minR","_spawnBurst","_spawnPoint","_spawnPolygonalChain","spawnPolygon","frequency","pos","clone","emit","undefined","autoUpdate","prev","removeChild","newRot","diff","rotatePoint","resetPositionTracking","remove","add","playOnceAndDestroy","callback","playOnce","settings","TARGET_FPMS","prevX","prevY","curX","curY","Math","random","emitPosX","emitPosY","len","particleConstructor","floor","alphaList","reset","speedMultiplier","speedList","scaleMultiplier","scaleList","colorList","children","shift","pop","index","indexOf","splice","unshift","addChildAt","addChild","position","width","height","radius","angle","getRandomPoint","PropertyList_1","Sprite","Particle","anchor","velocity","age","_doAlpha","_doScale","_doSpeed","_doAcceleration","_doColor","_doNormalMovement","_oneOverLife","Sprite_destroy","kill","current","DEG_TO_RADS","tint","combineRGBComponents","visible","interpolate","normalize","scaleBy","currentSpeed","atan2","verbose","baseTexture","console","warn","BLEND_MODES","ParticleUtils","PI","sin","c","cos","xnew","ynew","point","oneOverLen","sqrt","hexToRGB","charAt","substr","parseInt","segments","qty","oneOverQty","time","cp","name","NORMAL","toUpperCase","replace","createSteppedGradient","list","numSteps","first","isStepped","currentNode","nextIndex","curVal","nextVal","MATH_FUNCS","WHITELISTER","RegExp","concat","join","parsePath","pathString","matches","match","Function","PathParticle","path","initialRotation","initialPosition","movement","error","PolygonalChain","countingLengths","totalLength","chain","prevPoint","second","p1","p2","_a","segLength","out","chosenSeg","rand","intValueSimple","intColorSimple","intValueComplex","intColorComplex","intValueStepped","intColorStepped","PropertyList","isColor","PropertyNode","array","node","start","end","ParticleUtils_js_1","Particle_js_1","Emitter_js_1","PathParticle_js_1","AnimatedParticle_js_1","particles","prop"],"mappings":"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","file":"pixi-particles.min.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Particle_1 = require(\"./Particle\");\r\nvar Texture = PIXI.Texture;\r\n/**\r\n * An individual particle image with an animation. Art data passed to the emitter must be\r\n * formatted in a particular way for AnimatedParticle to be able to handle it:\r\n *\r\n *     {\r\n *         //framerate is required. It is the animation speed of the particle in frames per\r\n *         //second.\r\n *         //A value of \"matchLife\" causes the animation to match the lifetime of an individual\r\n *         //particle, instead of at a constant framerate. This causes the animation to play\r\n *         //through one time, completing when the particle expires.\r\n *         framerate: 6,\r\n *         //loop is optional, and defaults to false.\r\n *         loop: true,\r\n *         //textures is required, and can be an array of any (non-zero) length.\r\n *         textures: [\r\n *             //each entry represents a single texture that should be used for one or more\r\n *             //frames. Any strings will be converted to Textures with Texture.fromImage().\r\n *             //Instances of PIXI.Texture will be used directly.\r\n *             \"animFrame1.png\",\r\n *             //entries can be an object with a 'count' property, telling AnimatedParticle to\r\n *             //use that texture for 'count' frames sequentially.\r\n *             {\r\n *                 texture: \"animFrame2.png\",\r\n *                 count: 3\r\n *             },\r\n *             \"animFrame3.png\"\r\n *         ]\r\n *     }\r\n *\r\n * @memberof PIXI.particles\r\n * @class AnimatedParticle\r\n * @extends PIXI.particles.Particle\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this AnimatedParticle.\r\n */\r\nvar AnimatedParticle = /** @class */ (function (_super) {\r\n    __extends(AnimatedParticle, _super);\r\n    function AnimatedParticle(emitter) {\r\n        var _this = _super.call(this, emitter) || this;\r\n        _this.textures = null;\r\n        _this.duration = 0;\r\n        _this.framerate = 0;\r\n        _this.elapsed = 0;\r\n        _this.loop = false;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     * @method PIXI.particles.AnimatedParticle#init\r\n     */\r\n    AnimatedParticle.prototype.init = function () {\r\n        this.Particle_init();\r\n        this.elapsed = 0;\r\n        //if the animation needs to match the particle's life, then cacluate variables\r\n        if (this.framerate < 0) {\r\n            this.duration = this.maxLife;\r\n            this.framerate = this.textures.length / this.duration;\r\n        }\r\n    };\r\n    /**\r\n     * Sets the textures for the particle.\r\n     * @method PIXI.particles.AnimatedParticle#applyArt\r\n     * @param {Array} art An array of PIXI.Texture objects for this animated particle.\r\n     */\r\n    AnimatedParticle.prototype.applyArt = function (art) {\r\n        this.textures = art.textures;\r\n        this.framerate = art.framerate;\r\n        this.duration = art.duration;\r\n        this.loop = art.loop;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @method PIXI.particles.AnimatedParticle#update\r\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    AnimatedParticle.prototype.update = function (delta) {\r\n        var lerp = this.Particle_update(delta);\r\n        //only animate the particle if it is still alive\r\n        if (lerp >= 0) {\r\n            this.elapsed += delta;\r\n            if (this.elapsed > this.duration) {\r\n                //loop elapsed back around\r\n                if (this.loop)\r\n                    this.elapsed = this.elapsed % this.duration;\r\n                else\r\n                    this.elapsed = this.duration - 0.000001;\r\n            }\r\n            var frame = (this.elapsed * this.framerate + 0.0000001) | 0;\r\n            this.texture = this.textures[frame] || PIXI.Texture.EMPTY;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     * @method PIXI.particles.AnimatedParticle#destroy\r\n     */\r\n    AnimatedParticle.prototype.destroy = function () {\r\n        this.Particle_destroy();\r\n        this.textures = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time.\r\n     * @method PIXI.particles.AnimatedParticle.parseArt\r\n     * @static\r\n     * @param  {Array} art The array of art data, properly formatted for AnimatedParticle.\r\n     * @return {Array} The art, after any needed modifications.\r\n     */\r\n    AnimatedParticle.parseArt = function (art) {\r\n        var data, output, textures, tex, outTextures;\r\n        var outArr = [];\r\n        for (var i = 0; i < art.length; ++i) {\r\n            data = art[i];\r\n            outArr[i] = output = {};\r\n            output.textures = outTextures = [];\r\n            textures = data.textures;\r\n            for (var j = 0; j < textures.length; ++j) {\r\n                tex = textures[j];\r\n                if (typeof tex == \"string\")\r\n                    outTextures.push(Texture.fromImage(tex));\r\n                else if (tex instanceof Texture)\r\n                    outTextures.push(tex);\r\n                else {\r\n                    var dupe = tex.count || 1;\r\n                    if (typeof tex.texture == \"string\")\r\n                        tex = Texture.fromImage(tex.texture);\r\n                    else\r\n                        tex = tex.texture;\r\n                    for (; dupe > 0; --dupe) {\r\n                        outTextures.push(tex);\r\n                    }\r\n                }\r\n            }\r\n            //use these values to signify that the animation should match the particle life time.\r\n            if (data.framerate == \"matchLife\") {\r\n                //-1 means that it should be calculated\r\n                output.framerate = -1;\r\n                output.duration = 0;\r\n                output.loop = false;\r\n            }\r\n            else {\r\n                //determine if the animation should loop\r\n                output.loop = !!data.loop;\r\n                //get the framerate, default to 60\r\n                output.framerate = data.framerate > 0 ? data.framerate : 60;\r\n                //determine the duration\r\n                output.duration = outTextures.length / output.framerate;\r\n            }\r\n        }\r\n        return outArr;\r\n    };\r\n    return AnimatedParticle;\r\n}(Particle_1.default));\r\nexports.default = AnimatedParticle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\r\nvar Particle_1 = require(\"./Particle\");\r\nvar PropertyNode_1 = require(\"./PropertyNode\");\r\nvar PolygonalChain_1 = require(\"./PolygonalChain\");\r\nvar ticker = PIXI.ticker.shared;\r\nvar helperPoint = new PIXI.Point();\r\n/**\r\n * A particle emitter.\r\n * @memberof PIXI.particles\r\n * @class Emitter\r\n * @constructor\r\n * @param {PIXI.Container} particleParent The container to add the\r\n *                                                     particles to.\r\n * @param {Array|PIXI.Texture|String} [particleImages] A texture or array of textures to use\r\n *                                                     for the particles. Strings will be turned\r\n *                                                     into textures via Texture.fromImage().\r\n * @param {Object} [config] A configuration object containing settings for the emitter.\r\n * @param {Boolean} [config.emit=true] If config.emit is explicitly passed as false, the Emitter\r\n *                                     will start disabled.\r\n * @param {Boolean} [config.autoUpdate=false] If config.emit is explicitly passed as true, the Emitter\r\n *                                     will automatically call update via the PIXI shared ticker.\r\n */\r\nvar Emitter = /** @class */ (function () {\r\n    function Emitter(particleParent, particleImages, config) {\r\n        this._particleConstructor = Particle_1.default;\r\n        //properties for individual particles\r\n        this.particleImages = null;\r\n        this.startAlpha = null;\r\n        this.startSpeed = null;\r\n        this.minimumSpeedMultiplier = 1;\r\n        this.acceleration = null;\r\n        this.maxSpeed = NaN;\r\n        this.startScale = null;\r\n        this.minimumScaleMultiplier = 1;\r\n        this.startColor = null;\r\n        this.minLifetime = 0;\r\n        this.maxLifetime = 0;\r\n        this.minStartRotation = 0;\r\n        this.maxStartRotation = 0;\r\n        this.noRotation = false;\r\n        this.minRotationSpeed = 0;\r\n        this.maxRotationSpeed = 0;\r\n        this.particleBlendMode = 0;\r\n        this.customEase = null;\r\n        this.extraData = null;\r\n        //properties for spawning particles\r\n        this._frequency = 1;\r\n        this.spawnChance = 1;\r\n        this.maxParticles = 1000;\r\n        this.emitterLifetime = -1;\r\n        this.spawnPos = null;\r\n        this.spawnType = null;\r\n        this._spawnFunc = null;\r\n        this.spawnRect = null;\r\n        this.spawnCircle = null;\r\n        this.spawnPolygonalChain = null;\r\n        this.particlesPerWave = 1;\r\n        this.particleSpacing = 0;\r\n        this.angleStart = 0;\r\n        //emitter properties\r\n        this.rotation = 0;\r\n        this.ownerPos = null;\r\n        this._prevEmitterPos = null;\r\n        this._prevPosIsValid = false;\r\n        this._posChanged = false;\r\n        this._parent = null;\r\n        this.addAtBack = false;\r\n        this.particleCount = 0;\r\n        this._emit = false;\r\n        this._spawnTimer = 0;\r\n        this._emitterLife = -1;\r\n        this._activeParticlesFirst = null;\r\n        this._activeParticlesLast = null;\r\n        this._poolFirst = null;\r\n        this._origConfig = null;\r\n        this._origArt = null;\r\n        this._autoUpdate = false;\r\n        this._destroyWhenComplete = false;\r\n        this._completeCallback = null;\r\n        //set the initial parent\r\n        this.parent = particleParent;\r\n        if (particleImages && config)\r\n            this.init(particleImages, config);\r\n        //save often used functions on the instance instead of the prototype for better speed\r\n        this.recycle = this.recycle;\r\n        this.update = this.update;\r\n        this.rotate = this.rotate;\r\n        this.updateSpawnPos = this.updateSpawnPos;\r\n        this.updateOwnerPos = this.updateOwnerPos;\r\n    }\r\n    Object.defineProperty(Emitter.prototype, \"frequency\", {\r\n        /**\r\n         * Time between particle spawns in seconds. If this value is not a number greater than 0,\r\n         * it will be set to 1 (particle per second) to prevent infinite loops.\r\n         * @member {Number} PIXI.particles.Emitter#frequency\r\n         */\r\n        get: function () { return this._frequency; },\r\n        set: function (value) {\r\n            //do some error checking to prevent infinite loops\r\n            if (typeof value == \"number\" && value > 0)\r\n                this._frequency = value;\r\n            else\r\n                this._frequency = 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"particleConstructor\", {\r\n        /**\r\n         * The constructor used to create new particles. The default is\r\n         * the built in Particle class. Setting this will dump any active or\r\n         * pooled particles, if the emitter has already been used.\r\n         * @member {Function} PIXI.particles.Emitter#particleConstructor\r\n         */\r\n        get: function () { return this._particleConstructor; },\r\n        set: function (value) {\r\n            if (value != this._particleConstructor) {\r\n                this._particleConstructor = value;\r\n                //clean up existing particles\r\n                this.cleanup();\r\n                //scrap all the particles\r\n                for (var particle = this._poolFirst; particle; particle = particle.next) {\r\n                    particle.destroy();\r\n                }\r\n                this._poolFirst = null;\r\n                //re-initialize the emitter so that the new constructor can do anything it needs to\r\n                if (this._origConfig && this._origArt)\r\n                    this.init(this._origArt, this._origConfig);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"parent\", {\r\n        /**\r\n        * The container to add particles to. Settings this will dump any active particles.\r\n        * @member {PIXI.Container} PIXI.particles.Emitter#parent\r\n        */\r\n        get: function () { return this._parent; },\r\n        set: function (value) {\r\n            this.cleanup();\r\n            this._parent = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Sets up the emitter based on the config settings.\r\n     * @method PIXI.particles.Emitter#init\r\n     * @param {Array|PIXI.Texture} art A texture or array of textures to use for the particles.\r\n     * @param {Object} config A configuration object containing settings for the emitter.\r\n     */\r\n    Emitter.prototype.init = function (art, config) {\r\n        if (!art || !config)\r\n            return;\r\n        //clean up any existing particles\r\n        this.cleanup();\r\n        //store the original config and particle images, in case we need to re-initialize\r\n        //when the particle constructor is changed\r\n        this._origConfig = config;\r\n        this._origArt = art;\r\n        //set up the array of data, also ensuring that it is an array\r\n        art = Array.isArray(art) ? art.slice() : [art];\r\n        //run the art through the particle class's parsing function\r\n        var partClass = this._particleConstructor;\r\n        this.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\r\n        ///////////////////////////\r\n        // Particle Properties   //\r\n        ///////////////////////////\r\n        //set up the alpha\r\n        if (config.alpha) {\r\n            this.startAlpha = PropertyNode_1.default.createList(config.alpha);\r\n        }\r\n        else\r\n            this.startAlpha = new PropertyNode_1.default(1, 0);\r\n        //set up the speed\r\n        if (config.speed) {\r\n            this.startSpeed = PropertyNode_1.default.createList(config.speed);\r\n            this.minimumSpeedMultiplier = config.speed.minimumSpeedMultiplier || 1;\r\n        }\r\n        else {\r\n            this.minimumSpeedMultiplier = 1;\r\n            this.startSpeed = new PropertyNode_1.default(0, 0);\r\n        }\r\n        //set up acceleration\r\n        var acceleration = config.acceleration;\r\n        if (acceleration && (acceleration.x || acceleration.y)) {\r\n            //make sure we disable speed interpolation\r\n            this.startSpeed.next = null;\r\n            this.acceleration = new PIXI.Point(acceleration.x, acceleration.y);\r\n            this.maxSpeed = config.maxSpeed || NaN;\r\n        }\r\n        else\r\n            this.acceleration = new PIXI.Point();\r\n        //set up the scale\r\n        if (config.scale) {\r\n            this.startScale = PropertyNode_1.default.createList(config.scale);\r\n            this.minimumScaleMultiplier = config.scale.minimumScaleMultiplier || 1;\r\n        }\r\n        else {\r\n            this.startScale = new PropertyNode_1.default(1, 0);\r\n            this.minimumScaleMultiplier = 1;\r\n        }\r\n        //set up the color\r\n        if (config.color) {\r\n            this.startColor = PropertyNode_1.default.createList(config.color);\r\n        }\r\n        else {\r\n            this.startColor = new PropertyNode_1.default({ r: 0xFF, g: 0xFF, b: 0xFF }, 0);\r\n        }\r\n        //set up the start rotation\r\n        if (config.startRotation) {\r\n            this.minStartRotation = config.startRotation.min;\r\n            this.maxStartRotation = config.startRotation.max;\r\n        }\r\n        else\r\n            this.minStartRotation = this.maxStartRotation = 0;\r\n        if (config.noRotation &&\r\n            (this.minStartRotation || this.maxStartRotation)) {\r\n            this.noRotation = !!config.noRotation;\r\n        }\r\n        else\r\n            this.noRotation = false;\r\n        //set up the rotation speed\r\n        if (config.rotationSpeed) {\r\n            this.minRotationSpeed = config.rotationSpeed.min;\r\n            this.maxRotationSpeed = config.rotationSpeed.max;\r\n        }\r\n        else\r\n            this.minRotationSpeed = this.maxRotationSpeed = 0;\r\n        //set up the lifetime\r\n        this.minLifetime = config.lifetime.min;\r\n        this.maxLifetime = config.lifetime.max;\r\n        //get the blend mode\r\n        this.particleBlendMode = ParticleUtils_1.default.getBlendMode(config.blendMode);\r\n        //use the custom ease if provided\r\n        if (config.ease) {\r\n            this.customEase = typeof config.ease == \"function\" ?\r\n                config.ease :\r\n                ParticleUtils_1.default.generateEase(config.ease);\r\n        }\r\n        else\r\n            this.customEase = null;\r\n        //set up the extra data, running it through the particle class's parseData function.\r\n        if (partClass.parseData)\r\n            this.extraData = partClass.parseData(config.extraData);\r\n        else\r\n            this.extraData = config.extraData || null;\r\n        //////////////////////////\r\n        // Emitter Properties   //\r\n        //////////////////////////\r\n        //reset spawn type specific settings\r\n        this.spawnRect = this.spawnCircle = null;\r\n        this.particlesPerWave = 1;\r\n        if (config.particlesPerWave && config.particlesPerWave > 1)\r\n            this.particlesPerWave = config.particlesPerWave;\r\n        this.particleSpacing = 0;\r\n        this.angleStart = 0;\r\n        var spawnCircle;\r\n        //determine the spawn function to use\r\n        switch (config.spawnType) {\r\n            case \"rect\":\r\n                this.spawnType = \"rect\";\r\n                this._spawnFunc = this._spawnRect;\r\n                var spawnRect = config.spawnRect;\r\n                this.spawnRect = new PIXI.Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\r\n                break;\r\n            case \"circle\":\r\n                this.spawnType = \"circle\";\r\n                this._spawnFunc = this._spawnCircle;\r\n                spawnCircle = config.spawnCircle;\r\n                this.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\r\n                break;\r\n            case \"ring\":\r\n                this.spawnType = \"ring\";\r\n                this._spawnFunc = this._spawnRing;\r\n                spawnCircle = config.spawnCircle;\r\n                this.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\r\n                this.spawnCircle.minRadius = spawnCircle.minR;\r\n                break;\r\n            case \"burst\":\r\n                this.spawnType = \"burst\";\r\n                this._spawnFunc = this._spawnBurst;\r\n                this.particleSpacing = config.particleSpacing;\r\n                this.angleStart = config.angleStart ? config.angleStart : 0;\r\n                break;\r\n            case \"point\":\r\n                this.spawnType = \"point\";\r\n                this._spawnFunc = this._spawnPoint;\r\n                break;\r\n            case \"polygonalChain\":\r\n                this.spawnType = \"polygonalChain\";\r\n                this._spawnFunc = this._spawnPolygonalChain;\r\n                this.spawnPolygonalChain = new PolygonalChain_1.default(config.spawnPolygon);\r\n                break;\r\n            default:\r\n                this.spawnType = \"point\";\r\n                this._spawnFunc = this._spawnPoint;\r\n                break;\r\n        }\r\n        //set the spawning frequency\r\n        this.frequency = config.frequency;\r\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\r\n        //set the emitter lifetime\r\n        this.emitterLifetime = config.emitterLifetime || -1;\r\n        //set the max particles\r\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\r\n        //determine if we should add the particle at the back of the list or not\r\n        this.addAtBack = !!config.addAtBack;\r\n        //reset the emitter position and rotation variables\r\n        this.rotation = 0;\r\n        this.ownerPos = new PIXI.Point();\r\n        this.spawnPos = new PIXI.Point(config.pos.x, config.pos.y);\r\n        this._prevEmitterPos = this.spawnPos.clone();\r\n        //previous emitter position is invalid and should not be used for interpolation\r\n        this._prevPosIsValid = false;\r\n        //start emitting\r\n        this._spawnTimer = 0;\r\n        this.emit = config.emit === undefined ? true : !!config.emit;\r\n        this.autoUpdate = config.autoUpdate === undefined ? false : !!config.autoUpdate;\r\n    };\r\n    /**\r\n     * Recycles an individual particle.\r\n     * @method PIXI.particles.Emitter#recycle\r\n     * @param {Particle} particle The particle to recycle.\r\n     * @private\r\n     */\r\n    Emitter.prototype.recycle = function (particle) {\r\n        if (particle.next)\r\n            particle.next.prev = particle.prev;\r\n        if (particle.prev)\r\n            particle.prev.next = particle.next;\r\n        if (particle == this._activeParticlesLast)\r\n            this._activeParticlesLast = particle.prev;\r\n        if (particle == this._activeParticlesFirst)\r\n            this._activeParticlesFirst = particle.next;\r\n        //add to pool\r\n        particle.prev = null;\r\n        particle.next = this._poolFirst;\r\n        this._poolFirst = particle;\r\n        //remove child from display, or make it invisible if it is in a ParticleContainer\r\n        if (particle.parent)\r\n            particle.parent.removeChild(particle);\r\n        //decrease count\r\n        --this.particleCount;\r\n    };\r\n    /**\r\n     * Sets the rotation of the emitter to a new value.\r\n     * @method PIXI.particles.Emitter#rotate\r\n     * @param {Number} newRot The new rotation, in degrees.\r\n     */\r\n    Emitter.prototype.rotate = function (newRot) {\r\n        if (this.rotation == newRot)\r\n            return;\r\n        //caclulate the difference in rotation for rotating spawnPos\r\n        var diff = newRot - this.rotation;\r\n        this.rotation = newRot;\r\n        //rotate spawnPos\r\n        ParticleUtils_1.default.rotatePoint(diff, this.spawnPos);\r\n        //mark the position as having changed\r\n        this._posChanged = true;\r\n    };\r\n    /**\r\n     * Changes the spawn position of the emitter.\r\n     * @method PIXI.particles.Emitter#updateSpawnPos\r\n     * @param {Number} x The new x value of the spawn position for the emitter.\r\n     * @param {Number} y The new y value of the spawn position for the emitter.\r\n     */\r\n    Emitter.prototype.updateSpawnPos = function (x, y) {\r\n        this._posChanged = true;\r\n        this.spawnPos.x = x;\r\n        this.spawnPos.y = y;\r\n    };\r\n    /**\r\n     * Changes the position of the emitter's owner. You should call this if you are adding\r\n     * particles to the world container that your emitter's owner is moving around in.\r\n     * @method PIXI.particles.Emitter#updateOwnerPos\r\n     * @param {Number} x The new x value of the emitter's owner.\r\n     * @param {Number} y The new y value of the emitter's owner.\r\n     */\r\n    Emitter.prototype.updateOwnerPos = function (x, y) {\r\n        this._posChanged = true;\r\n        this.ownerPos.x = x;\r\n        this.ownerPos.y = y;\r\n    };\r\n    /**\r\n     * Prevents emitter position interpolation in the next update.\r\n     * This should be used if you made a major position change of your emitter's owner\r\n     * that was not normal movement.\r\n     * @method PIXI.particles.Emitter#resetPositionTracking\r\n     */\r\n    Emitter.prototype.resetPositionTracking = function () {\r\n        this._prevPosIsValid = false;\r\n    };\r\n    Object.defineProperty(Emitter.prototype, \"emit\", {\r\n        /**\r\n         * If particles should be emitted during update() calls. Setting this to false\r\n         * stops new particles from being created, but allows existing ones to die out.\r\n         * @member {Boolean} PIXI.particles.Emitter#emit\r\n         */\r\n        get: function () { return this._emit; },\r\n        set: function (value) {\r\n            this._emit = !!value;\r\n            this._emitterLife = this.emitterLifetime;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(Emitter.prototype, \"autoUpdate\", {\r\n        /**\r\n         * If the update function is called automatically from the shared ticker.\r\n         * Setting this to false requires calling the update function manually.\r\n         * @member {Boolean} PIXI.particles.Emitter#autoUpdate\r\n         */\r\n        get: function () { return this._autoUpdate; },\r\n        set: function (value) {\r\n            if (this._autoUpdate && !value) {\r\n                ticker.remove(this.update, this);\r\n            }\r\n            else if (!this._autoUpdate && value) {\r\n                ticker.add(this.update, this);\r\n            }\r\n            this._autoUpdate = !!value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\r\n     * when particle emission is complete.\r\n     * @method PIXI.particles.Emitter#playOnceAndDestroy\r\n     * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\r\n     */\r\n    Emitter.prototype.playOnceAndDestroy = function (callback) {\r\n        this.autoUpdate = true;\r\n        this.emit = true;\r\n        this._destroyWhenComplete = true;\r\n        this._completeCallback = callback;\r\n    };\r\n    /**\r\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\r\n     * @method PIXI.particles.Emitter#playOnce\r\n     * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\r\n     */\r\n    Emitter.prototype.playOnce = function (callback) {\r\n        this.emit = true;\r\n        this._completeCallback = callback;\r\n    };\r\n    /**\r\n     * Updates all particles spawned by this emitter and emits new ones.\r\n     * @method PIXI.particles.Emitter#update\r\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    Emitter.prototype.update = function (delta) {\r\n        if (this._autoUpdate) {\r\n            delta = delta / PIXI.settings.TARGET_FPMS / 1000;\r\n        }\r\n        //if we don't have a parent to add particles to, then don't do anything.\r\n        //this also works as a isDestroyed check\r\n        if (!this._parent)\r\n            return;\r\n        //update existing particles\r\n        var i, particle, next;\r\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\r\n            next = particle.next;\r\n            particle.update(delta);\r\n        }\r\n        var prevX, prevY;\r\n        //if the previous position is valid, store these for later interpolation\r\n        if (this._prevPosIsValid) {\r\n            prevX = this._prevEmitterPos.x;\r\n            prevY = this._prevEmitterPos.y;\r\n        }\r\n        //store current position of the emitter as local variables\r\n        var curX = this.ownerPos.x + this.spawnPos.x;\r\n        var curY = this.ownerPos.y + this.spawnPos.y;\r\n        //spawn new particles\r\n        if (this._emit) {\r\n            //decrease spawn timer\r\n            this._spawnTimer -= delta < 0 ? 0 : delta;\r\n            //while _spawnTimer < 0, we have particles to spawn\r\n            while (this._spawnTimer <= 0) {\r\n                //determine if the emitter should stop spawning\r\n                if (this._emitterLife > 0) {\r\n                    this._emitterLife -= this._frequency;\r\n                    if (this._emitterLife <= 0) {\r\n                        this._spawnTimer = 0;\r\n                        this._emitterLife = 0;\r\n                        this.emit = false;\r\n                        break;\r\n                    }\r\n                }\r\n                //determine if we have hit the particle limit\r\n                if (this.particleCount >= this.maxParticles) {\r\n                    this._spawnTimer += this._frequency;\r\n                    continue;\r\n                }\r\n                //determine the particle lifetime\r\n                var lifetime = void 0;\r\n                if (this.minLifetime == this.maxLifetime)\r\n                    lifetime = this.minLifetime;\r\n                else\r\n                    lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\r\n                //only make the particle if it wouldn't immediately destroy itself\r\n                if (-this._spawnTimer < lifetime) {\r\n                    //If the position has changed and this isn't the first spawn,\r\n                    //interpolate the spawn position\r\n                    var emitPosX = void 0, emitPosY = void 0;\r\n                    if (this._prevPosIsValid && this._posChanged) {\r\n                        //1 - _spawnTimer / delta, but _spawnTimer is negative\r\n                        var lerp = 1 + this._spawnTimer / delta;\r\n                        emitPosX = (curX - prevX) * lerp + prevX;\r\n                        emitPosY = (curY - prevY) * lerp + prevY;\r\n                    }\r\n                    else {\r\n                        emitPosX = curX;\r\n                        emitPosY = curY;\r\n                    }\r\n                    //create enough particles to fill the wave (non-burst types have a wave of 1)\r\n                    i = 0;\r\n                    for (var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i) {\r\n                        //see if we actually spawn one\r\n                        if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\r\n                            continue;\r\n                        //create particle\r\n                        var p = void 0;\r\n                        if (this._poolFirst) {\r\n                            p = this._poolFirst;\r\n                            this._poolFirst = this._poolFirst.next;\r\n                            p.next = null;\r\n                        }\r\n                        else {\r\n                            p = new this.particleConstructor(this);\r\n                        }\r\n                        //set a random texture if we have more than one\r\n                        if (this.particleImages.length > 1) {\r\n                            p.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\r\n                        }\r\n                        else {\r\n                            //if they are actually the same texture, a standard particle\r\n                            //will quit early from the texture setting in setTexture().\r\n                            p.applyArt(this.particleImages[0]);\r\n                        }\r\n                        //set up the start and end values\r\n                        p.alphaList.reset(this.startAlpha);\r\n                        if (this.minimumSpeedMultiplier != 1) {\r\n                            p.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\r\n                        }\r\n                        p.speedList.reset(this.startSpeed);\r\n                        p.acceleration.x = this.acceleration.x;\r\n                        p.acceleration.y = this.acceleration.y;\r\n                        p.maxSpeed = this.maxSpeed;\r\n                        if (this.minimumScaleMultiplier != 1) {\r\n                            p.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\r\n                        }\r\n                        p.scaleList.reset(this.startScale);\r\n                        p.colorList.reset(this.startColor);\r\n                        //randomize the rotation speed\r\n                        if (this.minRotationSpeed == this.maxRotationSpeed)\r\n                            p.rotationSpeed = this.minRotationSpeed;\r\n                        else\r\n                            p.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\r\n                        p.noRotation = this.noRotation;\r\n                        //set up the lifetime\r\n                        p.maxLife = lifetime;\r\n                        //set the blend mode\r\n                        p.blendMode = this.particleBlendMode;\r\n                        //set the custom ease, if any\r\n                        p.ease = this.customEase;\r\n                        //set the extra data, if any\r\n                        p.extraData = this.extraData;\r\n                        //call the proper function to handle rotation and position of particle\r\n                        this._spawnFunc(p, emitPosX, emitPosY, i);\r\n                        //initialize particle\r\n                        p.init();\r\n                        //update the particle by the time passed, so the particles are spread out properly\r\n                        p.update(-this._spawnTimer); //we want a positive delta, because a negative delta messes things up\r\n                        //add the particle to the display list\r\n                        if (!p.parent) {\r\n                            if (this.addAtBack)\r\n                                this._parent.addChildAt(p, 0);\r\n                            else\r\n                                this._parent.addChild(p);\r\n                        }\r\n                        else {\r\n                            //kind of hacky, but performance friendly\r\n                            //shuffle children to correct place\r\n                            var children = this._parent.children;\r\n                            //avoid using splice if possible\r\n                            if (children[0] == p)\r\n                                children.shift();\r\n                            else if (children[children.length - 1] == p)\r\n                                children.pop();\r\n                            else {\r\n                                var index = children.indexOf(p);\r\n                                children.splice(index, 1);\r\n                            }\r\n                            if (this.addAtBack)\r\n                                children.unshift(p);\r\n                            else\r\n                                children.push(p);\r\n                        }\r\n                        //add particle to list of active particles\r\n                        if (this._activeParticlesLast) {\r\n                            this._activeParticlesLast.next = p;\r\n                            p.prev = this._activeParticlesLast;\r\n                            this._activeParticlesLast = p;\r\n                        }\r\n                        else {\r\n                            this._activeParticlesLast = this._activeParticlesFirst = p;\r\n                        }\r\n                        ++this.particleCount;\r\n                    }\r\n                }\r\n                //increase timer and continue on to any other particles that need to be created\r\n                this._spawnTimer += this._frequency;\r\n            }\r\n        }\r\n        //if the position changed before this update, then keep track of that\r\n        if (this._posChanged) {\r\n            this._prevEmitterPos.x = curX;\r\n            this._prevEmitterPos.y = curY;\r\n            this._prevPosIsValid = true;\r\n            this._posChanged = false;\r\n        }\r\n        //if we are all done and should destroy ourselves, take care of that\r\n        if (!this._emit && !this._activeParticlesFirst) {\r\n            if (this._completeCallback) {\r\n                this._completeCallback();\r\n            }\r\n            if (this._destroyWhenComplete) {\r\n                this.destroy();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Positions a particle for a point type emitter.\r\n     * @method PIXI.particles.Emitter#_spawnPoint\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnPoint = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on\r\n        //starting particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\r\n        //drop the particle at the emitter's position\r\n        p.position.x = emitPosX;\r\n        p.position.y = emitPosY;\r\n    };\r\n    /**\r\n     * Positions a particle for a rectangle type emitter.\r\n     * @method PIXI.particles.Emitter#_spawnRect\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnRect = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\r\n        //place the particle at a random point in the rectangle\r\n        helperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\r\n        helperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\r\n        if (this.rotation !== 0)\r\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a circle type emitter.\r\n     * @method PIXI.particles.Emitter#_spawnCircle\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnCircle = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        //place the particle at a random radius in the circle\r\n        helperPoint.x = Math.random() * this.spawnCircle.radius;\r\n        helperPoint.y = 0;\r\n        //rotate the point to a random angle in the circle\r\n        ParticleUtils_1.default.rotatePoint(Math.random() * 360, helperPoint);\r\n        //offset by the circle's center\r\n        helperPoint.x += this.spawnCircle.x;\r\n        helperPoint.y += this.spawnCircle.y;\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a ring type emitter.\r\n     * @method PIXI.particles.Emitter#_spawnRing\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnRing = function (p, emitPosX, emitPosY) {\r\n        var spawnCircle = this.spawnCircle;\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        //place the particle at a random radius in the ring\r\n        if (spawnCircle.minRadius !== spawnCircle.radius) {\r\n            helperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\r\n                spawnCircle.minRadius;\r\n        }\r\n        else\r\n            helperPoint.x = spawnCircle.radius;\r\n        helperPoint.y = 0;\r\n        //rotate the point to a random angle in the circle\r\n        var angle = Math.random() * 360;\r\n        p.rotation += angle;\r\n        ParticleUtils_1.default.rotatePoint(angle, helperPoint);\r\n        //offset by the circle's center\r\n        helperPoint.x += this.spawnCircle.x;\r\n        helperPoint.y += this.spawnCircle.y;\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for polygonal chain.\r\n     * @method PIXI.particles.Emitter#_spawnPolygonalChain\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnPolygonalChain = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        // get random point on the polygon chain\r\n        this.spawnPolygonalChain.getRandomPoint(helperPoint);\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a burst type emitter.\r\n     * @method PIXI.particles.Emitter#_spawnBurst\r\n     * @private\r\n     * @param {Particle} p The particle to position and rotate.\r\n     * @param {Number} emitPosX The emitter's x position\r\n     * @param {Number} emitPosY The emitter's y position\r\n     * @param {int} i The particle number in the current wave.\r\n     */\r\n    Emitter.prototype._spawnBurst = function (p, emitPosX, emitPosY, i) {\r\n        //set the initial rotation/direction of the particle based on spawn\r\n        //angle and rotation of emitter\r\n        if (this.particleSpacing === 0)\r\n            p.rotation = Math.random() * 360;\r\n        else\r\n            p.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\r\n        //drop the particle at the emitter's position\r\n        p.position.x = emitPosX;\r\n        p.position.y = emitPosY;\r\n    };\r\n    /**\r\n     * Kills all active particles immediately.\r\n     * @method PIXI.particles.Emitter#cleanup\r\n     */\r\n    Emitter.prototype.cleanup = function () {\r\n        var particle, next;\r\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\r\n            next = particle.next;\r\n            this.recycle(particle);\r\n            if (particle.parent)\r\n                particle.parent.removeChild(particle);\r\n        }\r\n        this._activeParticlesFirst = this._activeParticlesLast = null;\r\n        this.particleCount = 0;\r\n    };\r\n    /**\r\n     * Destroys the emitter and all of its particles.\r\n     * @method PIXI.particles.Emitter#destroy\r\n     */\r\n    Emitter.prototype.destroy = function () {\r\n        //make sure we aren't still listening to any tickers\r\n        this.autoUpdate = false;\r\n        //puts all active particles in the pool, and removes them from the particle parent\r\n        this.cleanup();\r\n        //wipe the pool clean\r\n        var next;\r\n        for (var particle = this._poolFirst; particle; particle = next) {\r\n            //store next value so we don't lose it in our destroy call\r\n            next = particle.next;\r\n            particle.destroy();\r\n        }\r\n        this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\r\n            this.startColor = this.startScale = this.startAlpha = this.startSpeed =\r\n                this.customEase = this._completeCallback = null;\r\n    };\r\n    return Emitter;\r\n}());\r\nexports.default = Emitter;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\r\nvar PropertyList_1 = require(\"./PropertyList\");\r\nvar Sprite = PIXI.Sprite;\r\n/**\r\n * An individual particle image. You shouldn't have to deal with these.\r\n * @memberof PIXI.particles\r\n * @class Particle\r\n * @extends PIXI.Sprite\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\r\n */\r\nvar Particle = /** @class */ (function (_super) {\r\n    __extends(Particle, _super);\r\n    function Particle(emitter) {\r\n        var _this = \r\n        //start off the sprite with a blank texture, since we are going to replace it\r\n        //later when the particle is initialized.\r\n        _super.call(this) || this;\r\n        _this.emitter = emitter;\r\n        //particles should be centered\r\n        _this.anchor.x = _this.anchor.y = 0.5;\r\n        _this.velocity = new PIXI.Point();\r\n        _this.maxLife = 0;\r\n        _this.age = 0;\r\n        _this.ease = null;\r\n        _this.extraData = null;\r\n        _this.alphaList = new PropertyList_1.default();\r\n        _this.speedList = new PropertyList_1.default();\r\n        _this.speedMultiplier = 1;\r\n        /**\r\n         * Acceleration to apply to the particle.\r\n         * @property {PIXI.Point} accleration\r\n         */\r\n        _this.acceleration = new PIXI.Point();\r\n        /**\r\n         * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r\n         * will disable the maximum speed.\r\n         * @property {Number} maxSpeed\r\n         * @default NaN\r\n         */\r\n        _this.maxSpeed = NaN;\r\n        /**\r\n         * The scale of the particle throughout its life.\r\n         * @property {PIXI.particles.PropertyList} scaleList\r\n         */\r\n        _this.scaleList = new PropertyList_1.default();\r\n        /**\r\n         * A multiplier from 0-1 applied to the scale of the particle at all times.\r\n         * @property {number} scaleMultiplier\r\n         */\r\n        _this.scaleMultiplier = 1;\r\n        /**\r\n         * The tint of the particle throughout its life.\r\n         * @property {PIXI.particles.PropertyList} colorList\r\n         */\r\n        _this.colorList = new PropertyList_1.default(true);\r\n        /**\r\n         * If alpha should be interpolated at all.\r\n         * @property {Boolean} _doAlpha\r\n         * @private\r\n         */\r\n        _this._doAlpha = false;\r\n        /**\r\n         * If scale should be interpolated at all.\r\n         * @property {Boolean} _doScale\r\n         * @private\r\n         */\r\n        _this._doScale = false;\r\n        /**\r\n         * If speed should be interpolated at all.\r\n         * @property {Boolean} _doSpeed\r\n         * @private\r\n         */\r\n        _this._doSpeed = false;\r\n        /**\r\n         * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\r\n         * and _doSpeed gets priority.\r\n         * @property {Boolean} _doAcceleration\r\n         * @private\r\n         */\r\n        _this._doAcceleration = false;\r\n        /**\r\n         * If color should be interpolated at all.\r\n         * @property {Boolean} _doColor\r\n         * @private\r\n         */\r\n        _this._doColor = false;\r\n        /**\r\n         * If normal movement should be handled. Subclasses wishing to override movement\r\n         * can set this to false in init().\r\n         * @property {Boolean} _doNormalMovement\r\n         * @private\r\n         */\r\n        _this._doNormalMovement = false;\r\n        /**\r\n         * One divided by the max life of the particle, saved for slightly faster math.\r\n         * @property {Number} _oneOverLife\r\n         * @private\r\n         */\r\n        _this._oneOverLife = 0;\r\n        /**\r\n         * Reference to the next particle in the list.\r\n         * @property {Particle} next\r\n         * @private\r\n         */\r\n        _this.next = null;\r\n        /**\r\n         * Reference to the previous particle in the list.\r\n         * @property {Particle} prev\r\n         * @private\r\n         */\r\n        _this.prev = null;\r\n        //save often used functions on the instance instead of the prototype for better speed\r\n        _this.init = _this.init;\r\n        _this.Particle_init = Particle.prototype.init;\r\n        _this.update = _this.update;\r\n        _this.Particle_update = Particle.prototype.update;\r\n        _this.Sprite_destroy = _super.prototype.destroy;\r\n        _this.Particle_destroy = Particle.prototype.destroy;\r\n        _this.applyArt = _this.applyArt;\r\n        _this.kill = _this.kill;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     * @method PIXI.particles.Particle#init\r\n     */\r\n    Particle.prototype.init = function () {\r\n        //reset the age\r\n        this.age = 0;\r\n        //set up the velocity based on the start speed and rotation\r\n        this.velocity.x = this.speedList.current.value * this.speedMultiplier;\r\n        this.velocity.y = 0;\r\n        ParticleUtils_1.default.rotatePoint(this.rotation, this.velocity);\r\n        if (this.noRotation) {\r\n            this.rotation = 0;\r\n        }\r\n        else {\r\n            //convert rotation to Radians from Degrees\r\n            this.rotation *= ParticleUtils_1.default.DEG_TO_RADS;\r\n        }\r\n        //convert rotation speed to Radians from Degrees\r\n        this.rotationSpeed *= ParticleUtils_1.default.DEG_TO_RADS;\r\n        //set alpha to inital alpha\r\n        this.alpha = this.alphaList.current.value;\r\n        //set scale to initial scale\r\n        this.scale.x = this.scale.y = this.scaleList.current.value;\r\n        //figure out what we need to interpolate\r\n        this._doAlpha = !!this.alphaList.current.next;\r\n        this._doSpeed = !!this.speedList.current.next;\r\n        this._doScale = !!this.scaleList.current.next;\r\n        this._doColor = !!this.colorList.current.next;\r\n        this._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\r\n        //_doNormalMovement can be cancelled by subclasses\r\n        this._doNormalMovement = this._doSpeed || this.speedList.current.value !== 0 || this._doAcceleration;\r\n        //save our lerp helper\r\n        this._oneOverLife = 1 / this.maxLife;\r\n        //set the inital color\r\n        var color = this.colorList.current.value;\r\n        this.tint = ParticleUtils_1.default.combineRGBComponents(color.r, color.g, color.b);\r\n        //ensure visibility\r\n        this.visible = true;\r\n    };\r\n    /**\r\n     * Sets the texture for the particle. This can be overridden to allow\r\n     * for an animated particle.\r\n     * @method PIXI.particles.Particle#applyArt\r\n     * @param {PIXI.Texture} art The texture to set.\r\n     */\r\n    Particle.prototype.applyArt = function (art) {\r\n        this.texture = art || PIXI.Texture.EMPTY;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @method PIXI.particles.Particle#update\r\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n     * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\r\n     *                   properties. A value of -1 means the particle died of old age instead.\r\n     */\r\n    Particle.prototype.update = function (delta) {\r\n        //increase age\r\n        this.age += delta;\r\n        //recycle particle if it is too old\r\n        if (this.age >= this.maxLife || this.age < 0) {\r\n            this.kill();\r\n            return -1;\r\n        }\r\n        //determine our interpolation value\r\n        var lerp = this.age * this._oneOverLife; //lifetime / maxLife;\r\n        if (this.ease) {\r\n            if (this.ease.length == 4) {\r\n                //the t, b, c, d parameters that some tween libraries use\r\n                //(time, initial value, end value, duration)\r\n                lerp = this.ease(lerp, 0, 1, 1);\r\n            }\r\n            else {\r\n                //the simplified version that we like that takes\r\n                //one parameter, time from 0-1. TweenJS eases provide this usage.\r\n                lerp = this.ease(lerp);\r\n            }\r\n        }\r\n        //interpolate alpha\r\n        if (this._doAlpha)\r\n            this.alpha = this.alphaList.interpolate(lerp);\r\n        //interpolate scale\r\n        if (this._doScale) {\r\n            var scale = this.scaleList.interpolate(lerp) * this.scaleMultiplier;\r\n            this.scale.x = this.scale.y = scale;\r\n        }\r\n        //handle movement\r\n        if (this._doNormalMovement) {\r\n            //interpolate speed\r\n            if (this._doSpeed) {\r\n                var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\r\n                ParticleUtils_1.default.normalize(this.velocity);\r\n                ParticleUtils_1.default.scaleBy(this.velocity, speed);\r\n            }\r\n            else if (this._doAcceleration) {\r\n                this.velocity.x += this.acceleration.x * delta;\r\n                this.velocity.y += this.acceleration.y * delta;\r\n                if (this.maxSpeed) {\r\n                    var currentSpeed = ParticleUtils_1.default.length(this.velocity);\r\n                    //if we are going faster than we should, clamp at the max speed\r\n                    //DO NOT recalculate vector length\r\n                    if (currentSpeed > this.maxSpeed) {\r\n                        ParticleUtils_1.default.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\r\n                    }\r\n                }\r\n            }\r\n            //adjust position based on velocity\r\n            this.position.x += this.velocity.x * delta;\r\n            this.position.y += this.velocity.y * delta;\r\n        }\r\n        //interpolate color\r\n        if (this._doColor) {\r\n            this.tint = this.colorList.interpolate(lerp);\r\n        }\r\n        //update rotation\r\n        if (this.rotationSpeed !== 0) {\r\n            this.rotation += this.rotationSpeed * delta;\r\n        }\r\n        else if (this.acceleration && !this.noRotation) {\r\n            this.rotation = Math.atan2(this.velocity.y, this.velocity.x); // + Math.PI / 2;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Kills the particle, removing it from the display list\r\n     * and telling the emitter to recycle it.\r\n     * @method PIXI.particles.Particle#kill\r\n     */\r\n    Particle.prototype.kill = function () {\r\n        this.emitter.recycle(this);\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     * @method PIXI.particles.Particle#destroy\r\n     */\r\n    Particle.prototype.destroy = function () {\r\n        if (this.parent)\r\n            this.parent.removeChild(this);\r\n        this.Sprite_destroy();\r\n        this.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList =\r\n            this.speedList = this.ease = this.next = this.prev = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time.\r\n     * @method PIXI.particles.Particle.parseArt\r\n     * @static\r\n     * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\r\n     *                     Any strings in the array will be converted to Textures via\r\n     *                     Texture.fromImage().\r\n     * @return {Array} The art, after any needed modifications.\r\n     */\r\n    Particle.parseArt = function (art) {\r\n        //convert any strings to Textures.\r\n        var i;\r\n        for (i = art.length; i >= 0; --i) {\r\n            if (typeof art[i] == \"string\")\r\n                art[i] = PIXI.Texture.fromImage(art[i]);\r\n        }\r\n        //particles from different base textures will be slower in WebGL than if they\r\n        //were from one spritesheet\r\n        if (ParticleUtils_1.default.verbose) {\r\n            for (i = art.length - 1; i > 0; --i) {\r\n                if (art[i].baseTexture != art[i - 1].baseTexture) {\r\n                    if (window.console)\r\n                        console.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return art;\r\n    };\r\n    /**\r\n     * Parses extra emitter data to ensure it is set up for this particle class.\r\n     * Particle does nothing to the extra data.\r\n     * @method PIXI.particles.Particle.parseData\r\n     * @static\r\n     * @param  {Object} extraData The extra data from the particle config.\r\n     * @return {Object} The parsed extra data.\r\n     */\r\n    Particle.parseData = function (extraData) {\r\n        return extraData;\r\n    };\r\n    return Particle;\r\n}(Sprite));\r\nexports.default = Particle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BLEND_MODES = PIXI.BLEND_MODES;\r\nvar PropertyNode_1 = require(\"./PropertyNode\");\r\n/**\r\n * Contains helper functions for particles and emitters to use.\r\n * @memberof PIXI.particles\r\n * @class ParticleUtils\r\n * @static\r\n */\r\nvar ParticleUtils = {\r\n    /**\r\n     * If errors and warnings should be logged within the library.\r\n     * @name PIXI.particles.ParticleUtils.verbose\r\n     * @default false\r\n     * @static\r\n     */\r\n    verbose: false,\r\n    DEG_TO_RADS: Math.PI / 180,\r\n    /**\r\n     * Rotates a point by a given angle.\r\n     * @method PIXI.particles.ParticleUtils.rotatePoint\r\n     * @param {Number} angle The angle to rotate by in degrees\r\n     * @param {PIXI.Point} p The point to rotate around 0,0.\r\n     * @static\r\n     */\r\n    rotatePoint: function (angle, p) {\r\n        if (!angle)\r\n            return;\r\n        angle *= ParticleUtils.DEG_TO_RADS;\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        var xnew = p.x * c - p.y * s;\r\n        var ynew = p.x * s + p.y * c;\r\n        p.x = xnew;\r\n        p.y = ynew;\r\n    },\r\n    /**\r\n     * Combines separate color components (0-255) into a single uint color.\r\n     * @method PIXI.particles.ParticleUtils.combineRGBComponents\r\n     * @param {uint} r The red value of the color\r\n     * @param {uint} g The green value of the color\r\n     * @param {uint} b The blue value of the color\r\n     * @return {uint} The color in the form of 0xRRGGBB\r\n     * @static\r\n     */\r\n    combineRGBComponents: function (r, g, b /*, a*/) {\r\n        return /*a << 24 |*/ r << 16 | g << 8 | b;\r\n    },\r\n    /**\r\n     * Reduces the point to a length of 1.\r\n     * @method PIXI.particles.ParticleUtils.normalize\r\n     * @static\r\n     * @param {PIXI.Point} point The point to normalize\r\n     */\r\n    normalize: function (point) {\r\n        var oneOverLen = 1 / ParticleUtils.length(point);\r\n        point.x *= oneOverLen;\r\n        point.y *= oneOverLen;\r\n    },\r\n    /**\r\n     * Multiplies the x and y values of this point by a value.\r\n     * @method PIXI.particles.ParticleUtils.scaleBy\r\n     * @static\r\n     * @param {PIXI.Point} point The point to scaleBy\r\n     * @param {number} value The value to scale by.\r\n     */\r\n    scaleBy: function (point, value) {\r\n        point.x *= value;\r\n        point.y *= value;\r\n    },\r\n    /**\r\n     * Returns the length (or magnitude) of this point.\r\n     * @method PIXI.particles.ParticleUtils.length\r\n     * @static\r\n     * @param {PIXI.Point} point The point to measure length\r\n     * @return The length of this point.\r\n     */\r\n    length: function (point) {\r\n        return Math.sqrt(point.x * point.x + point.y * point.y);\r\n    },\r\n    /**\r\n     * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\r\n     * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\r\n     * {r, g, b, (a)}.\r\n     * @method PIXI.particles.ParticleUtils.hexToRGB\r\n     * @param {string} color The input color string.\r\n     * @param {Object} [output] An object to put the output in. If omitted, a new object is created.\r\n     * @return The object with r, g, and b properties, possibly with an a property.\r\n     * @static\r\n     */\r\n    hexToRGB: function (color, output) {\r\n        if (!output)\r\n            output = {};\r\n        if (color.charAt(0) == \"#\")\r\n            color = color.substr(1);\r\n        else if (color.indexOf(\"0x\") === 0)\r\n            color = color.substr(2);\r\n        var alpha;\r\n        if (color.length == 8) {\r\n            alpha = color.substr(0, 2);\r\n            color = color.substr(2);\r\n        }\r\n        output.r = parseInt(color.substr(0, 2), 16); //Red\r\n        output.g = parseInt(color.substr(2, 2), 16); //Green\r\n        output.b = parseInt(color.substr(4, 2), 16); //Blue\r\n        if (alpha)\r\n            output.a = parseInt(alpha, 16);\r\n        return output;\r\n    },\r\n    /**\r\n     * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\r\n     * by the related tool at http://www.greensock.com/customease/.\r\n     * @method PIXI.particles.ParticleUtils.generateEase\r\n     * @param {Array} segments An array of segments, as created by\r\n     * http://www.greensock.com/customease/.\r\n     * @return {Function} A function that calculates the percentage of change at\r\n     *                    a given point in time (0-1 inclusive).\r\n     * @static\r\n     */\r\n    generateEase: function (segments) {\r\n        var qty = segments.length;\r\n        var oneOverQty = 1 / qty;\r\n        /*\r\n         * Calculates the percentage of change at a given point in time (0-1 inclusive).\r\n         * @param {Number} time The time of the ease, 0-1 inclusive.\r\n         * @return {Number} The percentage of the change, 0-1 inclusive (unless your\r\n         *                  ease goes outside those bounds).\r\n         */\r\n        return function (time) {\r\n            var t, s;\r\n            var i = (qty * time) | 0; //do a quick floor operation\r\n            t = (time - (i * oneOverQty)) * qty;\r\n            s = segments[i] || segments[qty - 1];\r\n            return (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\r\n        };\r\n    },\r\n    /**\r\n     * Gets a blend mode, ensuring that it is valid.\r\n     * @method PIXI.particles.ParticleUtils.getBlendMode\r\n     * @param {string} name The name of the blend mode to get.\r\n     * @return {int} The blend mode as specified in the PIXI.BLEND_MODES enumeration.\r\n     * @static\r\n     */\r\n    getBlendMode: function (name) {\r\n        if (!name)\r\n            return BLEND_MODES.NORMAL;\r\n        name = name.toUpperCase();\r\n        while (name.indexOf(\" \") >= 0)\r\n            name = name.replace(\" \", \"_\");\r\n        return BLEND_MODES[name] || BLEND_MODES.NORMAL;\r\n    },\r\n    /**\r\n     * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\r\n     * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\r\n     * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\r\n     * @method PIXI.particles.ParticleUtils.createSteppedGradient\r\n     * @param {Array} list The list of data to convert.\r\n     * @param {number} [numSteps=10] The number of steps to use.\r\n     * @return {PIXI.particles.PropertyNode} The blend mode as specified in the PIXI.blendModes enumeration.\r\n     * @static\r\n     */\r\n    createSteppedGradient: function (list, numSteps) {\r\n        if (numSteps === void 0) { numSteps = 10; }\r\n        if (typeof numSteps !== 'number' || numSteps <= 0)\r\n            numSteps = 10;\r\n        var first = new PropertyNode_1.default(list[0].value, list[0].time);\r\n        first.isStepped = true;\r\n        var currentNode = first;\r\n        var current = list[0];\r\n        var nextIndex = 1;\r\n        var next = list[nextIndex];\r\n        for (var i = 1; i < numSteps; ++i) {\r\n            var lerp = i / numSteps;\r\n            //ensure we are on the right segment, if multiple\r\n            while (lerp > next.time) {\r\n                current = next;\r\n                next = list[++nextIndex];\r\n            }\r\n            //convert the lerp value to the segment range\r\n            lerp = (lerp - current.time) / (next.time - current.time);\r\n            var curVal = ParticleUtils.hexToRGB(current.value);\r\n            var nextVal = ParticleUtils.hexToRGB(next.value);\r\n            var output = {};\r\n            output.r = (nextVal.r - curVal.r) * lerp + curVal.r;\r\n            output.g = (nextVal.g - curVal.g) * lerp + curVal.g;\r\n            output.b = (nextVal.b - curVal.b) * lerp + curVal.b;\r\n            currentNode.next = new PropertyNode_1.default(output, i / numSteps);\r\n            currentNode = currentNode.next;\r\n        }\r\n        //we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\r\n        //the particle has died of old age\r\n        return first;\r\n    }\r\n};\r\nexports.default = ParticleUtils;\r\n","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\r\nvar Particle_1 = require(\"./Particle\");\r\n/**\r\n * A helper point for math things.\r\n * @private\r\n */\r\nvar helperPoint = new PIXI.Point();\r\n//a hand picked list of Math functions (and a couple properties) that are allowable.\r\n//they should be used without the preceding \"Math.\"\r\nvar MATH_FUNCS = [\r\n    \"pow\",\r\n    \"sqrt\",\r\n    \"abs\",\r\n    \"floor\",\r\n    \"round\",\r\n    \"ceil\",\r\n    \"E\",\r\n    \"PI\",\r\n    \"sin\",\r\n    \"cos\",\r\n    \"tan\",\r\n    \"asin\",\r\n    \"acos\",\r\n    \"atan\",\r\n    \"atan2\",\r\n    \"log\"\r\n];\r\n//create an actual regular expression object from the string\r\nvar WHITELISTER = new RegExp([\r\n    //Allow the 4 basic operations, parentheses and all numbers/decimals, as well\r\n    //as 'x', for the variable usage.\r\n    \"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\",\r\n].concat(MATH_FUNCS).join(\"|\"), \"g\");\r\n/**\r\n * Parses a string into a function for path following.\r\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\r\n * names, and using `new Function()` to generate a function.\r\n * @method PIXI.particles.PathParticle~parsePath\r\n * @private\r\n * @static\r\n * @param {String} pathString The string to parse.\r\n * @return {Function} The path function - takes x, outputs y.\r\n */\r\nvar parsePath = function (pathString) {\r\n    var matches = pathString.match(WHITELISTER);\r\n    for (var i = matches.length - 1; i >= 0; --i) {\r\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\r\n            matches[i] = \"Math.\" + matches[i];\r\n    }\r\n    pathString = matches.join(\"\");\r\n    return new Function(\"x\", \"return \" + pathString + \";\");\r\n};\r\n/**\r\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\r\n * \"5x + 3\".\r\n * To use this class, the particle config must have a \"path\" string in the\r\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\r\n * speed settings of the particle). It may have numbers, parentheses, the four basic\r\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\r\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\r\n * \"acos\", \"atan\", \"atan2\", \"log\".\r\n * The overall movement of the particle and the expression value become x and y positions for\r\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\r\n * the particle.\r\n *\r\n * Some example paths:\r\n *\r\n * \t\"sin(x/10) * 20\" // A sine wave path.\r\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\r\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\r\n *\r\n * @memberof PIXI.particles\r\n * @class PathParticle\r\n * @extends PIXI.particles.Particle\r\n * @constructor\r\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\r\n */\r\nvar PathParticle = /** @class */ (function (_super) {\r\n    __extends(PathParticle, _super);\r\n    function PathParticle(emitter) {\r\n        var _this = _super.call(this, emitter) || this;\r\n        _this.path = null;\r\n        _this.initialRotation = 0;\r\n        _this.initialPosition = new PIXI.Point();\r\n        _this.movement = 0;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     * @method PIXI.particles.PathParticle#init\r\n     */\r\n    PathParticle.prototype.init = function () {\r\n        //get initial rotation before it is converted to radians\r\n        this.initialRotation = this.rotation;\r\n        //standard init\r\n        this.Particle_init();\r\n        //set the path for the particle\r\n        this.path = this.extraData.path;\r\n        //cancel the normal movement behavior\r\n        this._doNormalMovement = !this.path;\r\n        //reset movement\r\n        this.movement = 0;\r\n        //grab position\r\n        this.initialPosition.x = this.position.x;\r\n        this.initialPosition.y = this.position.y;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @method PIXI.particles.PathParticle#update\r\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    PathParticle.prototype.update = function (delta) {\r\n        var lerp = this.Particle_update(delta);\r\n        //if the particle died during the update, then don't bother\r\n        if (lerp >= 0 && this.path) {\r\n            //increase linear movement based on speed\r\n            var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\r\n            this.movement += speed * delta;\r\n            //set up the helper point for rotation\r\n            helperPoint.x = this.movement;\r\n            helperPoint.y = this.path(this.movement);\r\n            ParticleUtils_1.default.rotatePoint(this.initialRotation, helperPoint);\r\n            this.position.x = this.initialPosition.x + helperPoint.x;\r\n            this.position.y = this.initialPosition.y + helperPoint.y;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     * @method PIXI.particles.PathParticle#destroy\r\n     */\r\n    PathParticle.prototype.destroy = function () {\r\n        this.Particle_destroy();\r\n        this.path = this.initialPosition = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time. This just runs Particle.parseArt().\r\n     * @method PIXI.particles.PathParticle.parseArt\r\n     * @static\r\n     * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\r\n     *                     Any strings in the array will be converted to Textures via\r\n     *                     Texture.fromImage().\r\n     * @return {Array} The art, after any needed modifications.\r\n     */\r\n    PathParticle.parseArt = function (art) {\r\n        return Particle_1.default.parseArt(art);\r\n    };\r\n    /**\r\n     * Parses extra emitter data to ensure it is set up for this particle class.\r\n     * PathParticle checks for the existence of path data, and parses the path data for use\r\n     * by particle instances.\r\n     * @method PIXI.particles.PathParticle.parseData\r\n     * @static\r\n     * @param  {Object} extraData The extra data from the particle config.\r\n     * @return {Object} The parsed extra data.\r\n     */\r\n    PathParticle.parseData = function (extraData) {\r\n        var output = {};\r\n        if (extraData && extraData.path) {\r\n            try {\r\n                output.path = parsePath(extraData.path);\r\n            }\r\n            catch (e) {\r\n                if (ParticleUtils_1.default.verbose)\r\n                    console.error(\"PathParticle: error in parsing path expression\");\r\n                output.path = null;\r\n            }\r\n        }\r\n        else {\r\n            if (ParticleUtils_1.default.verbose)\r\n                console.error(\"PathParticle requires a path string in extraData!\");\r\n            output.path = null;\r\n        }\r\n        return output;\r\n    };\r\n    return PathParticle;\r\n}(Particle_1.default));\r\nexports.default = PathParticle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Chain of line segments for generating spawn positions.\r\n * @memberof PIXI.particles\r\n * @class PolygonalChain\r\n * @constructor\r\n * @param {{x:number,y:number}[]|{x:number,y:number}[]} data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r\n */\r\nvar PolygonalChain = /** @class */ (function () {\r\n    function PolygonalChain(data) {\r\n        this.segments = [];\r\n        this.countingLengths = [];\r\n        this.totalLength = 0;\r\n        this.init(data);\r\n    }\r\n    PolygonalChain.prototype.init = function (data) {\r\n        // if data is not present, set up a segment of length 0\r\n        if (!data || !data.length) {\r\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\r\n        }\r\n        else {\r\n            if (Array.isArray(data[0])) {\r\n                // list of segment chains, each defined as a list of points\r\n                for (var i = 0; i < data.length; ++i) {\r\n                    // loop through the chain, connecting points\r\n                    var chain = data[i];\r\n                    var prevPoint = chain[0];\r\n                    for (var j = 1; j < chain.length; ++j) {\r\n                        var second = chain[j];\r\n                        this.segments.push({ p1: prevPoint, p2: second, l: 0 });\r\n                        prevPoint = second;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var prevPoint = data[0];\r\n                // list of points\r\n                for (var i = 1; i < data.length; ++i) {\r\n                    var second = data[i];\r\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\r\n                    prevPoint = second;\r\n                }\r\n            }\r\n        }\r\n        // now go through our segments to calculate the lengths so that we\r\n        // can set up a nice weighted random distribution\r\n        for (var i = 0; i < this.segments.length; ++i) {\r\n            var _a = this.segments[i], p1 = _a.p1, p2 = _a.p2;\r\n            var segLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\r\n            // save length so we can turn a random number into a 0-1 interpolation value later\r\n            this.segments[i].l = segLength;\r\n            this.totalLength += segLength;\r\n            // keep track of the length so far, counting up\r\n            this.countingLengths.push(this.totalLength);\r\n        }\r\n    };\r\n    /**\r\n     * Gets a random point in the chain.\r\n     * @method getRandomPoint\r\n     * @param {PIXI.Point} out The point to store the selected position in.\r\n     */\r\n    PolygonalChain.prototype.getRandomPoint = function (out) {\r\n        // select a random spot in the length of the chain\r\n        var rand = Math.random() * this.totalLength;\r\n        var chosenSeg;\r\n        var lerp;\r\n        // if only one segment, it wins\r\n        if (this.segments.length === 1) {\r\n            chosenSeg = this.segments[0];\r\n            lerp = rand;\r\n        }\r\n        else {\r\n            // otherwise, go through countingLengths until we have determined\r\n            // which segment we chose\r\n            for (var i = 0; i < this.countingLengths.length; ++i) {\r\n                if (rand < this.countingLengths[i]) {\r\n                    chosenSeg = this.segments[i];\r\n                    // set lerp equal to the length into that segment (i.e. the remainder after subtracting all the segments before it)\r\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // divide lerp by the segment length, to result in a 0-1 number.\r\n        lerp /= chosenSeg.l || 1;\r\n        var p1 = chosenSeg.p1, p2 = chosenSeg.p2;\r\n        // now calculate the position in the segment that the lerp value represents\r\n        out.x = p1.x + lerp * (p2.x - p1.x);\r\n        out.y = p1.y + lerp * (p2.y - p1.y);\r\n    };\r\n    return PolygonalChain;\r\n}());\r\nexports.default = PolygonalChain;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\r\n/**\r\n * Singly linked list container for keeping track of interpolated properties for particles.\r\n * Each Particle will have one of these for each interpolated property.\r\n * @memberof PIXI.particles\r\n * @class PropertyList\r\n * @constructor\r\n * @param {boolean} isColor If this list handles color values\r\n */\r\nvar PropertyList = /** @class */ (function () {\r\n    function PropertyList(isColor) {\r\n        if (isColor === void 0) { isColor = false; }\r\n        this.current = null;\r\n        this.next = null;\r\n        this.isColor = !!isColor;\r\n        this.interpolate = null;\r\n        this.ease = null;\r\n    }\r\n    /**\r\n     * Resets the list for use.\r\n     * @method interpolate\r\n     * @param {PIXI.particles.PropertyNode} first The first node in the list.\r\n     * @param {boolean} [isStepped=false] If the values should be stepped instead of interpolated linearly.\r\n     */\r\n    PropertyList.prototype.reset = function (first) {\r\n        this.current = first;\r\n        this.next = first.next;\r\n        var isSimple = this.next && this.next.time >= 1;\r\n        if (isSimple) {\r\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\r\n        }\r\n        else if (first.isStepped) {\r\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\r\n        }\r\n        else {\r\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\r\n        }\r\n        this.ease = this.current.ease;\r\n    };\r\n    return PropertyList;\r\n}());\r\nexports.default = PropertyList;\r\nfunction intValueSimple(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    return (this.next.value - this.current.value) * lerp + this.current.value;\r\n}\r\nfunction intColorSimple(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    var curVal = this.current.value, nextVal = this.next.value;\r\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\r\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\r\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\r\n    return ParticleUtils_1.default.combineRGBComponents(r, g, b);\r\n}\r\nfunction intValueComplex(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    //convert the lerp value to the segment range\r\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\r\n    return (this.next.value - this.current.value) * lerp + this.current.value;\r\n}\r\nfunction intColorComplex(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    //convert the lerp value to the segment range\r\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\r\n    var curVal = this.current.value, nextVal = this.next.value;\r\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\r\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\r\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\r\n    return ParticleUtils_1.default.combineRGBComponents(r, g, b);\r\n}\r\nfunction intValueStepped(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (this.next && lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    return this.current.value;\r\n}\r\nfunction intColorStepped(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (this.next && lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    var curVal = this.current.value;\r\n    return ParticleUtils_1.default.combineRGBComponents(curVal.r, curVal.g, curVal.b);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\r\n/**\r\n * A single node in a PropertyList.\r\n * @memberof PIXI.particles\r\n * @class PropertyNode\r\n * @constructor\r\n * @param {number|string} value The value for this node\r\n * @param {number} time The time for this node, between 0-1\r\n * @param {Function|Array} [ease] Custom ease for this list. Only relevant for the first node.\r\n */\r\nvar PropertyNode = /** @class */ (function () {\r\n    function PropertyNode(value, time, ease) {\r\n        this.value = typeof value == \"string\" ? ParticleUtils_1.default.hexToRGB(value) : value;\r\n        this.time = time;\r\n        this.next = null;\r\n        this.isStepped = false;\r\n        if (ease) {\r\n            this.ease = typeof ease == \"function\" ? ease : ParticleUtils_1.default.generateEase(ease);\r\n        }\r\n        else {\r\n            this.ease = null;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\r\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\r\n     * {start, end}.\r\n     * @method PIXI.particles.PropertyNode.createListFromArray\r\n     * @static\r\n     * @param  {Object} data The data for the list.\r\n     * @param  {Array} data.list The array of value and time objects.\r\n     * @param  {boolean} [data.isStepped] If the list is stepped rather than interpolated.\r\n     * @param  {Function|Array} [data.ease] Custom ease for this list.\r\n     * @return {PIXI.particles.PropertyNode} The first node in the list\r\n     */\r\n    PropertyNode.createList = function (data) {\r\n        if (Array.isArray(data.list)) {\r\n            var array = data.list;\r\n            var node = void 0, first = void 0;\r\n            first = node = new PropertyNode(array[0].value, array[0].time, data.ease);\r\n            //only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\r\n            if (array.length > 2 || (array.length === 2 && array[1].value !== array[0].value)) {\r\n                for (var i = 1; i < array.length; ++i) {\r\n                    node.next = new PropertyNode(array[i].value, array[i].time);\r\n                    node = node.next;\r\n                }\r\n            }\r\n            first.isStepped = !!data.isStepped;\r\n            return first;\r\n        }\r\n        else {\r\n            //Handle deprecated version here\r\n            var start = new PropertyNode(data.start, 0);\r\n            //only set up a next value if it is different from the starting value\r\n            if (data.end !== data.start)\r\n                start.next = new PropertyNode(data.end, 1);\r\n            return start;\r\n        }\r\n    };\r\n    return PropertyNode;\r\n}());\r\nexports.default = PropertyNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParticleUtils_js_1 = require(\"./ParticleUtils.js\");\r\nexports.ParticleUtils = ParticleUtils_js_1.default;\r\nvar Particle_js_1 = require(\"./Particle.js\");\r\nexports.Particle = Particle_js_1.default;\r\nvar Emitter_js_1 = require(\"./Emitter.js\");\r\nexports.Emitter = Emitter_js_1.default;\r\nvar PathParticle_js_1 = require(\"./PathParticle.js\");\r\nexports.PathParticle = PathParticle_js_1.default;\r\nvar AnimatedParticle_js_1 = require(\"./AnimatedParticle.js\");\r\nexports.AnimatedParticle = AnimatedParticle_js_1.default;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// If we're in the browser make sure PIXI is available\r\nif (typeof PIXI === 'undefined') {\r\n    throw \"pixi-particles requires pixi.js to be loaded first\";\r\n}\r\n//ensure that the particles namespace exist - PIXI 4 creates it itself, PIXI 3 does not\r\nif (!PIXI.particles) {\r\n    PIXI.particles = {};\r\n}\r\n// get the library itself\r\nvar particles = require(\"./particles\");\r\n// insert the library into the particles namespace on PIXI\r\nfor (var prop in particles) {\r\n    PIXI.particles[prop] = particles[prop];\r\n}\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n    module.exports = particles;\r\n}\r\n"],"sourceRoot":"."}